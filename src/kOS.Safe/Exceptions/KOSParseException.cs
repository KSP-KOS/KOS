using System;
using kOS.Safe.Compilation.KS;
using System.Text;

namespace kOS.Safe.Exceptions
{
    /// <summary>
    /// Thrown when the PARSING stage of the compile process encountered
    /// a problem.  (As opposed to when the actual manual code we wrote in
    /// Compiler.cs finds a problem.)  This refers to problems found by
    /// the parsing code that TinyPG autogenerated for us.
    /// </summary>
    public class KOSParseException: KOSException
    {
        private readonly string verboseMessage;

        public override string VerboseMessage { get { return verboseMessage; } }
        public override string HelpURL {get{ return "";}}
         
        
        /// <summary>
        /// Create a parse exception message from one of TinyPG's ParseError
        /// objects, and the text of the script.
        /// </summary>
        /// <param name="tinyPGError">TinyPG's ParseError object</param>
        /// <param name="scriptText">Text of the script that was being parsed</param>
        public KOSParseException(ParseError tinyPGError, string scriptText) : 
            base( BuildTerseMessageFromTPGError(tinyPGError, scriptText) )
        {
            verboseMessage = BuildVerboseMessageFromTPGError(tinyPGError, scriptText);
        }
        
        private static string BuildTerseMessageFromTPGError(ParseError tpgErr, string scriptText)
        {
            // Logic moved here from Script.cs.  I'm not happy with how some of this is
            // hardcoded to assume output to our Terminal screen, but we can come
            // back to that issue later.

            const int LINE_SIZE = 50;
            int minStartIndex = Math.Max(tpgErr.Position - 40, 0);
            int maxEndIndex = scriptText.Length - 1;

            int startIndex = scriptText.LastIndexOf('\n', Math.Max(tpgErr.Position - 1, 0)) + 1;
            if (startIndex < minStartIndex) startIndex = minStartIndex;
            int endIndex = scriptText.IndexOf('\n', tpgErr.Position);
            if (endIndex == -1 || endIndex - startIndex > LINE_SIZE) endIndex = startIndex + LINE_SIZE;
            if (endIndex > maxEndIndex) endIndex = maxEndIndex;
            string errorScript = scriptText.Substring(startIndex, (endIndex - startIndex) + 1);

            var parseMessage = new StringBuilder();
            parseMessage.AppendLine(string.Format("Syntax: {0} at line {1}", tpgErr.Message, tpgErr.Line));
            parseMessage.AppendLine(errorScript);
            parseMessage.AppendLine(new string(' ', tpgErr.Position - startIndex) + "^");

            return parseMessage.ToString();
        }

        private static string BuildVerboseMessageFromTPGError(ParseError tpgErr, string scriptText)
        {
            // This uses the left/right arrow chars in the font.png file:
            // like so: markStart = the '->' char and markStop = the '<-' char.
            // Maybe in the future if the terminal supports color escape
            // codes, these strings can be changed to use them to highlight
            // the problem area instead of inserting arrow pictures in the line.
            char[] markStart = { (char)26 };
            char[] markStop = { (char)27 };

            const string FORMAT_STR = "The parser used by kOS is complaining about a\n" +
                                     "part of the script it can't understand.  kOS uses\n" +
                                     "a parser-generator tool known as TinyPG, and the\n" +
                                     "text description you see from this error message\n" +
                                     "comes mostly from TinyPG, not from kOS itself.\n" +
                                     "\n" +
                                     "Error   Line: {0}\n" +
                                     "Error Column: {1}\n" +
                                     "Message: {2}\n" +
                                     "__________________________________________\n"+
                                     "{3}\n";
            
            // Scan backward to find the position 2 lines of code up:
            int posAbove = tpgErr.Position - 1;
            for (int eolnToGo = 2 ; posAbove >= 0 && eolnToGo > 0 ; --posAbove)
                if (scriptText[posAbove] == '\n')
                    --eolnToGo;

            // Scan forward to find the position 2 lines of code down:
            int posBelow = tpgErr.Position;
            for (int eolnToGo = 2 ; posBelow < scriptText.Length && eolnToGo > 0 ; ++posBelow)
                if (scriptText[posBelow] == '\n')
                    --eolnToGo;
            
            // Make a substring of that chunk of the code between posAbove and posBelow,
            string contextSnippet = scriptText.Substring( posAbove+1, posBelow-(posAbove+1));
            
            // Put the markers into it:
            contextSnippet = contextSnippet.Insert(tpgErr.Position - (posAbove+1), new String(markStart));
            contextSnippet = contextSnippet.Insert((tpgErr.Position + tpgErr.Length + markStart.Length) - (posAbove+1), new String(markStop));
            
            return String.Format(FORMAT_STR, tpgErr.Line, tpgErr.Column, tpgErr.Message, contextSnippet);
        }
    }
}
