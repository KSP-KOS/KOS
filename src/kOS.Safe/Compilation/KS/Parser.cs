// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;

namespace kOS.Safe.Compilation.KS
{
    #region Parser

    public partial class Parser 
    {
        private Scanner scanner;
        private ParseTree tree;
        
        public Parser(Scanner scanner)
        {
            this.scanner = scanner;
        }

         public ParseTree Parse(string input)
        {
            return Parse(input, "", new ParseTree());
        }

        public ParseTree Parse(string input, string fileName)
        {
            return Parse(input, fileName, new ParseTree());
        }

        public ParseTree Parse(string input, string fileName, ParseTree tree)
        {
            scanner.Init(input, fileName);

            this.tree = tree;
            ParseStart(tree);
            tree.Skipped = scanner.Skipped;

            return tree;
        }

        private void ParseStart(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Start), "Start");
            parent.Nodes.Add(node);


            
            tok = scanner.LookAhead(TokenType.SET, TokenType.IF, TokenType.UNTIL, TokenType.FROM, TokenType.UNLOCK, TokenType.PRINT, TokenType.ON, TokenType.TOGGLE, TokenType.WAIT, TokenType.WHEN, TokenType.STAGE, TokenType.CLEARSCREEN, TokenType.ADD, TokenType.REMOVE, TokenType.LOG, TokenType.BREAK, TokenType.PRESERVE, TokenType.PARAMETER, TokenType.FUNCTION, TokenType.LOCK, TokenType.DECLARE, TokenType.LOCAL, TokenType.GLOBAL, TokenType.RETURN, TokenType.SWITCH, TokenType.COPY, TokenType.RENAME, TokenType.DELETE, TokenType.EDIT, TokenType.RUN, TokenType.COMPILE, TokenType.LIST, TokenType.REBOOT, TokenType.SHUTDOWN, TokenType.FOR, TokenType.UNSET, TokenType.CURLYOPEN, TokenType.INTEGER, TokenType.DOUBLE, TokenType.TRUEFALSE, TokenType.IDENTIFIER, TokenType.FILEIDENT, TokenType.BRACKETOPEN, TokenType.STRING, TokenType.ATSIGN);
            while (tok.Type == TokenType.SET
                || tok.Type == TokenType.IF
                || tok.Type == TokenType.UNTIL
                || tok.Type == TokenType.FROM
                || tok.Type == TokenType.UNLOCK
                || tok.Type == TokenType.PRINT
                || tok.Type == TokenType.ON
                || tok.Type == TokenType.TOGGLE
                || tok.Type == TokenType.WAIT
                || tok.Type == TokenType.WHEN
                || tok.Type == TokenType.STAGE
                || tok.Type == TokenType.CLEARSCREEN
                || tok.Type == TokenType.ADD
                || tok.Type == TokenType.REMOVE
                || tok.Type == TokenType.LOG
                || tok.Type == TokenType.BREAK
                || tok.Type == TokenType.PRESERVE
                || tok.Type == TokenType.PARAMETER
                || tok.Type == TokenType.FUNCTION
                || tok.Type == TokenType.LOCK
                || tok.Type == TokenType.DECLARE
                || tok.Type == TokenType.LOCAL
                || tok.Type == TokenType.GLOBAL
                || tok.Type == TokenType.RETURN
                || tok.Type == TokenType.SWITCH
                || tok.Type == TokenType.COPY
                || tok.Type == TokenType.RENAME
                || tok.Type == TokenType.DELETE
                || tok.Type == TokenType.EDIT
                || tok.Type == TokenType.RUN
                || tok.Type == TokenType.COMPILE
                || tok.Type == TokenType.LIST
                || tok.Type == TokenType.REBOOT
                || tok.Type == TokenType.SHUTDOWN
                || tok.Type == TokenType.FOR
                || tok.Type == TokenType.UNSET
                || tok.Type == TokenType.CURLYOPEN
                || tok.Type == TokenType.INTEGER
                || tok.Type == TokenType.DOUBLE
                || tok.Type == TokenType.TRUEFALSE
                || tok.Type == TokenType.IDENTIFIER
                || tok.Type == TokenType.FILEIDENT
                || tok.Type == TokenType.BRACKETOPEN
                || tok.Type == TokenType.STRING
                || tok.Type == TokenType.ATSIGN)
            {
                Parseinstruction(node);
            tok = scanner.LookAhead(TokenType.SET, TokenType.IF, TokenType.UNTIL, TokenType.FROM, TokenType.UNLOCK, TokenType.PRINT, TokenType.ON, TokenType.TOGGLE, TokenType.WAIT, TokenType.WHEN, TokenType.STAGE, TokenType.CLEARSCREEN, TokenType.ADD, TokenType.REMOVE, TokenType.LOG, TokenType.BREAK, TokenType.PRESERVE, TokenType.PARAMETER, TokenType.FUNCTION, TokenType.LOCK, TokenType.DECLARE, TokenType.LOCAL, TokenType.GLOBAL, TokenType.RETURN, TokenType.SWITCH, TokenType.COPY, TokenType.RENAME, TokenType.DELETE, TokenType.EDIT, TokenType.RUN, TokenType.COMPILE, TokenType.LIST, TokenType.REBOOT, TokenType.SHUTDOWN, TokenType.FOR, TokenType.UNSET, TokenType.CURLYOPEN, TokenType.INTEGER, TokenType.DOUBLE, TokenType.TRUEFALSE, TokenType.IDENTIFIER, TokenType.FILEIDENT, TokenType.BRACKETOPEN, TokenType.STRING, TokenType.ATSIGN);
            }

            
            tok = scanner.Scan(TokenType.EOF);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOF) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseinstruction_block(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.instruction_block), "instruction_block");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.CURLYOPEN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CURLYOPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CURLYOPEN.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.SET, TokenType.IF, TokenType.UNTIL, TokenType.FROM, TokenType.UNLOCK, TokenType.PRINT, TokenType.ON, TokenType.TOGGLE, TokenType.WAIT, TokenType.WHEN, TokenType.STAGE, TokenType.CLEARSCREEN, TokenType.ADD, TokenType.REMOVE, TokenType.LOG, TokenType.BREAK, TokenType.PRESERVE, TokenType.PARAMETER, TokenType.FUNCTION, TokenType.LOCK, TokenType.DECLARE, TokenType.LOCAL, TokenType.GLOBAL, TokenType.RETURN, TokenType.SWITCH, TokenType.COPY, TokenType.RENAME, TokenType.DELETE, TokenType.EDIT, TokenType.RUN, TokenType.COMPILE, TokenType.LIST, TokenType.REBOOT, TokenType.SHUTDOWN, TokenType.FOR, TokenType.UNSET, TokenType.CURLYOPEN, TokenType.INTEGER, TokenType.DOUBLE, TokenType.TRUEFALSE, TokenType.IDENTIFIER, TokenType.FILEIDENT, TokenType.BRACKETOPEN, TokenType.STRING, TokenType.ATSIGN);
            while (tok.Type == TokenType.SET
                || tok.Type == TokenType.IF
                || tok.Type == TokenType.UNTIL
                || tok.Type == TokenType.FROM
                || tok.Type == TokenType.UNLOCK
                || tok.Type == TokenType.PRINT
                || tok.Type == TokenType.ON
                || tok.Type == TokenType.TOGGLE
                || tok.Type == TokenType.WAIT
                || tok.Type == TokenType.WHEN
                || tok.Type == TokenType.STAGE
                || tok.Type == TokenType.CLEARSCREEN
                || tok.Type == TokenType.ADD
                || tok.Type == TokenType.REMOVE
                || tok.Type == TokenType.LOG
                || tok.Type == TokenType.BREAK
                || tok.Type == TokenType.PRESERVE
                || tok.Type == TokenType.PARAMETER
                || tok.Type == TokenType.FUNCTION
                || tok.Type == TokenType.LOCK
                || tok.Type == TokenType.DECLARE
                || tok.Type == TokenType.LOCAL
                || tok.Type == TokenType.GLOBAL
                || tok.Type == TokenType.RETURN
                || tok.Type == TokenType.SWITCH
                || tok.Type == TokenType.COPY
                || tok.Type == TokenType.RENAME
                || tok.Type == TokenType.DELETE
                || tok.Type == TokenType.EDIT
                || tok.Type == TokenType.RUN
                || tok.Type == TokenType.COMPILE
                || tok.Type == TokenType.LIST
                || tok.Type == TokenType.REBOOT
                || tok.Type == TokenType.SHUTDOWN
                || tok.Type == TokenType.FOR
                || tok.Type == TokenType.UNSET
                || tok.Type == TokenType.CURLYOPEN
                || tok.Type == TokenType.INTEGER
                || tok.Type == TokenType.DOUBLE
                || tok.Type == TokenType.TRUEFALSE
                || tok.Type == TokenType.IDENTIFIER
                || tok.Type == TokenType.FILEIDENT
                || tok.Type == TokenType.BRACKETOPEN
                || tok.Type == TokenType.STRING
                || tok.Type == TokenType.ATSIGN)
            {
                Parseinstruction(node);
            tok = scanner.LookAhead(TokenType.SET, TokenType.IF, TokenType.UNTIL, TokenType.FROM, TokenType.UNLOCK, TokenType.PRINT, TokenType.ON, TokenType.TOGGLE, TokenType.WAIT, TokenType.WHEN, TokenType.STAGE, TokenType.CLEARSCREEN, TokenType.ADD, TokenType.REMOVE, TokenType.LOG, TokenType.BREAK, TokenType.PRESERVE, TokenType.PARAMETER, TokenType.FUNCTION, TokenType.LOCK, TokenType.DECLARE, TokenType.LOCAL, TokenType.GLOBAL, TokenType.RETURN, TokenType.SWITCH, TokenType.COPY, TokenType.RENAME, TokenType.DELETE, TokenType.EDIT, TokenType.RUN, TokenType.COMPILE, TokenType.LIST, TokenType.REBOOT, TokenType.SHUTDOWN, TokenType.FOR, TokenType.UNSET, TokenType.CURLYOPEN, TokenType.INTEGER, TokenType.DOUBLE, TokenType.TRUEFALSE, TokenType.IDENTIFIER, TokenType.FILEIDENT, TokenType.BRACKETOPEN, TokenType.STRING, TokenType.ATSIGN);
            }

            
            tok = scanner.Scan(TokenType.CURLYCLOSE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CURLYCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CURLYCLOSE.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.EOI);
            if (tok.Type == TokenType.EOI)
            {
                tok = scanner.Scan(TokenType.EOI);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.EOI) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseinstruction(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.instruction), "instruction");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.SET, TokenType.IF, TokenType.UNTIL, TokenType.FROM, TokenType.UNLOCK, TokenType.PRINT, TokenType.ON, TokenType.TOGGLE, TokenType.WAIT, TokenType.WHEN, TokenType.STAGE, TokenType.CLEARSCREEN, TokenType.ADD, TokenType.REMOVE, TokenType.LOG, TokenType.BREAK, TokenType.PRESERVE, TokenType.PARAMETER, TokenType.FUNCTION, TokenType.LOCK, TokenType.DECLARE, TokenType.LOCAL, TokenType.GLOBAL, TokenType.RETURN, TokenType.SWITCH, TokenType.COPY, TokenType.RENAME, TokenType.DELETE, TokenType.EDIT, TokenType.RUN, TokenType.COMPILE, TokenType.LIST, TokenType.REBOOT, TokenType.SHUTDOWN, TokenType.FOR, TokenType.UNSET, TokenType.CURLYOPEN, TokenType.INTEGER, TokenType.DOUBLE, TokenType.TRUEFALSE, TokenType.IDENTIFIER, TokenType.FILEIDENT, TokenType.BRACKETOPEN, TokenType.STRING, TokenType.ATSIGN);
            switch (tok.Type)
            {
                case TokenType.SET:
                    Parseset_stmt(node);
                    break;
                case TokenType.IF:
                    Parseif_stmt(node);
                    break;
                case TokenType.UNTIL:
                    Parseuntil_stmt(node);
                    break;
                case TokenType.FROM:
                    Parsefromloop_stmt(node);
                    break;
                case TokenType.UNLOCK:
                    Parseunlock_stmt(node);
                    break;
                case TokenType.PRINT:
                    Parseprint_stmt(node);
                    break;
                case TokenType.ON:
                    Parseon_stmt(node);
                    break;
                case TokenType.TOGGLE:
                    Parsetoggle_stmt(node);
                    break;
                case TokenType.WAIT:
                    Parsewait_stmt(node);
                    break;
                case TokenType.WHEN:
                    Parsewhen_stmt(node);
                    break;
                case TokenType.STAGE:
                    Parsestage_stmt(node);
                    break;
                case TokenType.CLEARSCREEN:
                    Parseclear_stmt(node);
                    break;
                case TokenType.ADD:
                    Parseadd_stmt(node);
                    break;
                case TokenType.REMOVE:
                    Parseremove_stmt(node);
                    break;
                case TokenType.LOG:
                    Parselog_stmt(node);
                    break;
                case TokenType.BREAK:
                    Parsebreak_stmt(node);
                    break;
                case TokenType.PRESERVE:
                    Parsepreserve_stmt(node);
                    break;
                case TokenType.PARAMETER:
                case TokenType.FUNCTION:
                case TokenType.LOCK:
                case TokenType.DECLARE:
                case TokenType.LOCAL:
                case TokenType.GLOBAL:
                    Parsedeclare_stmt(node);
                    break;
                case TokenType.RETURN:
                    Parsereturn_stmt(node);
                    break;
                case TokenType.SWITCH:
                    Parseswitch_stmt(node);
                    break;
                case TokenType.COPY:
                    Parsecopy_stmt(node);
                    break;
                case TokenType.RENAME:
                    Parserename_stmt(node);
                    break;
                case TokenType.DELETE:
                    Parsedelete_stmt(node);
                    break;
                case TokenType.EDIT:
                    Parseedit_stmt(node);
                    break;
                case TokenType.RUN:
                    Parserun_stmt(node);
                    break;
                case TokenType.COMPILE:
                    Parsecompile_stmt(node);
                    break;
                case TokenType.LIST:
                    Parselist_stmt(node);
                    break;
                case TokenType.REBOOT:
                    Parsereboot_stmt(node);
                    break;
                case TokenType.SHUTDOWN:
                    Parseshutdown_stmt(node);
                    break;
                case TokenType.FOR:
                    Parsefor_stmt(node);
                    break;
                case TokenType.UNSET:
                    Parseunset_stmt(node);
                    break;
                case TokenType.CURLYOPEN:
                    Parseinstruction_block(node);
                    break;
                case TokenType.INTEGER:
                case TokenType.DOUBLE:
                case TokenType.TRUEFALSE:
                case TokenType.IDENTIFIER:
                case TokenType.FILEIDENT:
                case TokenType.BRACKETOPEN:
                case TokenType.STRING:
                    Parseidentifier_led_stmt(node);
                    break;
                case TokenType.ATSIGN:
                    Parsedirective(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parselazyglobal_directive(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.lazyglobal_directive), "lazyglobal_directive");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.ATSIGN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ATSIGN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ATSIGN.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.LAZYGLOBAL);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LAZYGLOBAL) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LAZYGLOBAL.ToString(), 0x1001, tok));
                return;
            }

            
            Parseonoff_trailer(node);

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsedirective(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.directive), "directive");
            parent.Nodes.Add(node);

            Parselazyglobal_directive(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseset_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.set_stmt), "set_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.SET);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SET) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SET.ToString(), 0x1001, tok));
                return;
            }

            
            Parsevaridentifier(node);

            
            tok = scanner.Scan(TokenType.TO);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TO.ToString(), 0x1001, tok));
                return;
            }

            
            Parseexpr(node);

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseif_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.if_stmt), "if_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.IF);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IF) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IF.ToString(), 0x1001, tok));
                return;
            }

            
            Parseexpr(node);

            
            Parseinstruction(node);

            
            tok = scanner.LookAhead(TokenType.ELSE);
            if (tok.Type == TokenType.ELSE)
            {

                
                tok = scanner.Scan(TokenType.ELSE);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.ELSE) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ELSE.ToString(), 0x1001, tok));
                    return;
                }

                
                Parseinstruction(node);
            }

            
            tok = scanner.LookAhead(TokenType.EOI);
            if (tok.Type == TokenType.EOI)
            {
                tok = scanner.Scan(TokenType.EOI);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.EOI) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseuntil_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.until_stmt), "until_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.UNTIL);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.UNTIL) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.UNTIL.ToString(), 0x1001, tok));
                return;
            }

            
            Parseexpr(node);

            
            Parseinstruction(node);

            
            tok = scanner.LookAhead(TokenType.EOI);
            if (tok.Type == TokenType.EOI)
            {
                tok = scanner.Scan(TokenType.EOI);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.EOI) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsefromloop_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.fromloop_stmt), "fromloop_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.FROM);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.FROM) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FROM.ToString(), 0x1001, tok));
                return;
            }

            
            Parseinstruction_block(node);

            
            tok = scanner.Scan(TokenType.UNTIL);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.UNTIL) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.UNTIL.ToString(), 0x1001, tok));
                return;
            }

            
            Parseexpr(node);

            
            tok = scanner.Scan(TokenType.STEP);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.STEP) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STEP.ToString(), 0x1001, tok));
                return;
            }

            
            Parseinstruction_block(node);

            
            tok = scanner.Scan(TokenType.DO);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.DO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DO.ToString(), 0x1001, tok));
                return;
            }

            
            Parseinstruction(node);

            
            tok = scanner.LookAhead(TokenType.EOI);
            if (tok.Type == TokenType.EOI)
            {
                tok = scanner.Scan(TokenType.EOI);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.EOI) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseunlock_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.unlock_stmt), "unlock_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.UNLOCK);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.UNLOCK) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.UNLOCK.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.IDENTIFIER, TokenType.ALL);
            switch (tok.Type)
            {
                case TokenType.IDENTIFIER:
                    tok = scanner.Scan(TokenType.IDENTIFIER);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IDENTIFIER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.ALL:
                    tok = scanner.Scan(TokenType.ALL);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.ALL) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ALL.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                    break;
            }

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseprint_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.print_stmt), "print_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.PRINT);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PRINT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PRINT.ToString(), 0x1001, tok));
                return;
            }

            
            Parseexpr(node);

            
            tok = scanner.LookAhead(TokenType.AT);
            if (tok.Type == TokenType.AT)
            {

                
                tok = scanner.Scan(TokenType.AT);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.AT) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.AT.ToString(), 0x1001, tok));
                    return;
                }

                
                tok = scanner.Scan(TokenType.BRACKETOPEN);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.BRACKETOPEN) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString(), 0x1001, tok));
                    return;
                }

                
                Parseexpr(node);

                
                tok = scanner.Scan(TokenType.COMMA);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, tok));
                    return;
                }

                
                Parseexpr(node);

                
                tok = scanner.Scan(TokenType.BRACKETCLOSE);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.BRACKETCLOSE) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString(), 0x1001, tok));
                    return;
                }
            }

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseon_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.on_stmt), "on_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.ON);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ON) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ON.ToString(), 0x1001, tok));
                return;
            }

            
            Parsevaridentifier(node);

            
            Parseinstruction(node);

            
            tok = scanner.LookAhead(TokenType.EOI);
            if (tok.Type == TokenType.EOI)
            {
                tok = scanner.Scan(TokenType.EOI);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.EOI) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsetoggle_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.toggle_stmt), "toggle_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.TOGGLE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TOGGLE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TOGGLE.ToString(), 0x1001, tok));
                return;
            }

            
            Parsevaridentifier(node);

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsewait_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.wait_stmt), "wait_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.WAIT);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.WAIT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WAIT.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.UNTIL);
            if (tok.Type == TokenType.UNTIL)
            {
                tok = scanner.Scan(TokenType.UNTIL);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.UNTIL) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.UNTIL.ToString(), 0x1001, tok));
                    return;
                }
            }

            
            Parseexpr(node);

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsewhen_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.when_stmt), "when_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.WHEN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.WHEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WHEN.ToString(), 0x1001, tok));
                return;
            }

            
            Parseexpr(node);

            
            tok = scanner.Scan(TokenType.THEN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.THEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.THEN.ToString(), 0x1001, tok));
                return;
            }

            
            Parseinstruction(node);

            
            tok = scanner.LookAhead(TokenType.EOI);
            if (tok.Type == TokenType.EOI)
            {
                tok = scanner.Scan(TokenType.EOI);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.EOI) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseonoff_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.onoff_stmt), "onoff_stmt");
            parent.Nodes.Add(node);


            
            Parsevaridentifier(node);

            
            Parseonoff_trailer(node);

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseonoff_trailer(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.onoff_trailer), "onoff_trailer");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.ON, TokenType.OFF);
            switch (tok.Type)
            {
                case TokenType.ON:
                    tok = scanner.Scan(TokenType.ON);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.ON) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ON.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.OFF:
                    tok = scanner.Scan(TokenType.OFF);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.OFF) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OFF.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsestage_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.stage_stmt), "stage_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.STAGE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.STAGE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STAGE.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseclear_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.clear_stmt), "clear_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.CLEARSCREEN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CLEARSCREEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CLEARSCREEN.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseadd_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.add_stmt), "add_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.ADD);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ADD) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ADD.ToString(), 0x1001, tok));
                return;
            }

            
            Parseexpr(node);

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseremove_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.remove_stmt), "remove_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.REMOVE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.REMOVE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.REMOVE.ToString(), 0x1001, tok));
                return;
            }

            
            Parseexpr(node);

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parselog_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.log_stmt), "log_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.LOG);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LOG) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LOG.ToString(), 0x1001, tok));
                return;
            }

            
            Parseexpr(node);

            
            tok = scanner.Scan(TokenType.TO);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TO.ToString(), 0x1001, tok));
                return;
            }

            
            Parseexpr(node);

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsebreak_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.break_stmt), "break_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.BREAK);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BREAK) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BREAK.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsepreserve_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.preserve_stmt), "preserve_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.PRESERVE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PRESERVE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PRESERVE.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsedeclare_identifier_clause(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.declare_identifier_clause), "declare_identifier_clause");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.TO, TokenType.IS);
            switch (tok.Type)
            {
                case TokenType.TO:
                    tok = scanner.Scan(TokenType.TO);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.TO) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TO.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.IS:
                    tok = scanner.Scan(TokenType.IS);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IS) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IS.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                    break;
            }

            
            Parseexpr(node);

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsedeclare_parameter_clause(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.declare_parameter_clause), "declare_parameter_clause");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.PARAMETER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PARAMETER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PARAMETER.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.COMMA);
            while (tok.Type == TokenType.COMMA)
            {

                
                tok = scanner.Scan(TokenType.COMMA);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, tok));
                    return;
                }

                
                tok = scanner.Scan(TokenType.IDENTIFIER);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.IDENTIFIER) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                    return;
                }
            tok = scanner.LookAhead(TokenType.COMMA);
            }

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsedeclare_function_clause(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.declare_function_clause), "declare_function_clause");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.FUNCTION);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.FUNCTION) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FUNCTION.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

            
            Parseinstruction_block(node);

            
            tok = scanner.LookAhead(TokenType.EOI);
            if (tok.Type == TokenType.EOI)
            {
                tok = scanner.Scan(TokenType.EOI);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.EOI) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsedeclare_lock_clause(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.declare_lock_clause), "declare_lock_clause");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.LOCK);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LOCK) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LOCK.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.TO);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TO.ToString(), 0x1001, tok));
                return;
            }

            
            Parseexpr(node);

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsedeclare_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.declare_stmt), "declare_stmt");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.PARAMETER, TokenType.FUNCTION, TokenType.LOCK, TokenType.DECLARE, TokenType.LOCAL, TokenType.GLOBAL);
            switch (tok.Type)
            {
                case TokenType.PARAMETER:
                    Parsedeclare_parameter_clause(node);
                    break;
                case TokenType.FUNCTION:
                    Parsedeclare_function_clause(node);
                    break;
                case TokenType.LOCK:
                    Parsedeclare_lock_clause(node);
                    break;
                case TokenType.DECLARE:
                case TokenType.LOCAL:
                case TokenType.GLOBAL:

                    
                    tok = scanner.LookAhead(TokenType.DECLARE, TokenType.LOCAL, TokenType.GLOBAL);
                    switch (tok.Type)
                    {
                        case TokenType.DECLARE:

                            
                            tok = scanner.Scan(TokenType.DECLARE);
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.DECLARE) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DECLARE.ToString(), 0x1001, tok));
                                return;
                            }

                            
                            tok = scanner.LookAhead(TokenType.LOCAL, TokenType.GLOBAL);
                            if (tok.Type == TokenType.LOCAL
                                || tok.Type == TokenType.GLOBAL)
                            {
                                tok = scanner.LookAhead(TokenType.LOCAL, TokenType.GLOBAL);
                                switch (tok.Type)
                                {
                                    case TokenType.LOCAL:
                                        tok = scanner.Scan(TokenType.LOCAL);
                                        n = node.CreateNode(tok, tok.ToString() );
                                        node.Token.UpdateRange(tok);
                                        node.Nodes.Add(n);
                                        if (tok.Type != TokenType.LOCAL) {
                                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LOCAL.ToString(), 0x1001, tok));
                                            return;
                                        }
                                        break;
                                    case TokenType.GLOBAL:
                                        tok = scanner.Scan(TokenType.GLOBAL);
                                        n = node.CreateNode(tok, tok.ToString() );
                                        node.Token.UpdateRange(tok);
                                        node.Nodes.Add(n);
                                        if (tok.Type != TokenType.GLOBAL) {
                                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.GLOBAL.ToString(), 0x1001, tok));
                                            return;
                                        }
                                        break;
                                    default:
                                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                                        break;
                                }
                            }
                            break;
                        case TokenType.LOCAL:
                        case TokenType.GLOBAL:
                            tok = scanner.LookAhead(TokenType.LOCAL, TokenType.GLOBAL);
                            switch (tok.Type)
                            {
                                case TokenType.LOCAL:
                                    tok = scanner.Scan(TokenType.LOCAL);
                                    n = node.CreateNode(tok, tok.ToString() );
                                    node.Token.UpdateRange(tok);
                                    node.Nodes.Add(n);
                                    if (tok.Type != TokenType.LOCAL) {
                                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LOCAL.ToString(), 0x1001, tok));
                                        return;
                                    }
                                    break;
                                case TokenType.GLOBAL:
                                    tok = scanner.Scan(TokenType.GLOBAL);
                                    n = node.CreateNode(tok, tok.ToString() );
                                    node.Token.UpdateRange(tok);
                                    node.Nodes.Add(n);
                                    if (tok.Type != TokenType.GLOBAL) {
                                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.GLOBAL.ToString(), 0x1001, tok));
                                        return;
                                    }
                                    break;
                                default:
                                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                                    break;
                            }
                            break;
                        default:
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                            break;
                    }

                    
                    tok = scanner.LookAhead(TokenType.PARAMETER, TokenType.FUNCTION, TokenType.IDENTIFIER, TokenType.LOCK);
                    switch (tok.Type)
                    {
                        case TokenType.PARAMETER:
                            Parsedeclare_parameter_clause(node);
                            break;
                        case TokenType.FUNCTION:
                            Parsedeclare_function_clause(node);
                            break;
                        case TokenType.IDENTIFIER:
                            Parsedeclare_identifier_clause(node);
                            break;
                        case TokenType.LOCK:
                            Parsedeclare_lock_clause(node);
                            break;
                        default:
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                            break;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsereturn_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.return_stmt), "return_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.RETURN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RETURN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RETURN.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.PLUSMINUS, TokenType.NOT, TokenType.INTEGER, TokenType.DOUBLE, TokenType.TRUEFALSE, TokenType.IDENTIFIER, TokenType.FILEIDENT, TokenType.BRACKETOPEN, TokenType.STRING);
            if (tok.Type == TokenType.PLUSMINUS
                || tok.Type == TokenType.NOT
                || tok.Type == TokenType.INTEGER
                || tok.Type == TokenType.DOUBLE
                || tok.Type == TokenType.TRUEFALSE
                || tok.Type == TokenType.IDENTIFIER
                || tok.Type == TokenType.FILEIDENT
                || tok.Type == TokenType.BRACKETOPEN
                || tok.Type == TokenType.STRING)
            {
                Parseexpr(node);
            }

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseswitch_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.switch_stmt), "switch_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.SWITCH);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SWITCH) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SWITCH.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.TO);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TO.ToString(), 0x1001, tok));
                return;
            }

            
            Parseexpr(node);

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsecopy_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.copy_stmt), "copy_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.COPY);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.COPY) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COPY.ToString(), 0x1001, tok));
                return;
            }

            
            Parseexpr(node);

            
            tok = scanner.LookAhead(TokenType.FROM, TokenType.TO);
            switch (tok.Type)
            {
                case TokenType.FROM:
                    tok = scanner.Scan(TokenType.FROM);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.FROM) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FROM.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.TO:
                    tok = scanner.Scan(TokenType.TO);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.TO) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TO.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                    break;
            }

            
            Parseexpr(node);

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parserename_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.rename_stmt), "rename_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.RENAME);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RENAME) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RENAME.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.VOLUME, TokenType.FILE);
            if (tok.Type == TokenType.VOLUME
                || tok.Type == TokenType.FILE)
            {
                tok = scanner.LookAhead(TokenType.VOLUME, TokenType.FILE);
                switch (tok.Type)
                {
                    case TokenType.VOLUME:
                        tok = scanner.Scan(TokenType.VOLUME);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.VOLUME) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.VOLUME.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    case TokenType.FILE:
                        tok = scanner.Scan(TokenType.FILE);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.FILE) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FILE.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                        break;
                }
            }

            
            Parseexpr(node);

            
            tok = scanner.Scan(TokenType.TO);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TO.ToString(), 0x1001, tok));
                return;
            }

            
            Parseexpr(node);

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsedelete_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.delete_stmt), "delete_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.DELETE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.DELETE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DELETE.ToString(), 0x1001, tok));
                return;
            }

            
            Parseexpr(node);

            
            tok = scanner.LookAhead(TokenType.FROM);
            if (tok.Type == TokenType.FROM)
            {

                
                tok = scanner.Scan(TokenType.FROM);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.FROM) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FROM.ToString(), 0x1001, tok));
                    return;
                }

                
                Parseexpr(node);
            }

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseedit_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.edit_stmt), "edit_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.EDIT);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EDIT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EDIT.ToString(), 0x1001, tok));
                return;
            }

            
            Parseexpr(node);

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parserun_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.run_stmt), "run_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.RUN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RUN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RUN.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.FILEIDENT);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.FILEIDENT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FILEIDENT.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.BRACKETOPEN);
            if (tok.Type == TokenType.BRACKETOPEN)
            {

                
                tok = scanner.Scan(TokenType.BRACKETOPEN);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.BRACKETOPEN) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString(), 0x1001, tok));
                    return;
                }

                
                Parsearglist(node);

                
                tok = scanner.Scan(TokenType.BRACKETCLOSE);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.BRACKETCLOSE) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString(), 0x1001, tok));
                    return;
                }
            }

            
            tok = scanner.LookAhead(TokenType.ON);
            if (tok.Type == TokenType.ON)
            {

                
                tok = scanner.Scan(TokenType.ON);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.ON) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ON.ToString(), 0x1001, tok));
                    return;
                }

                
                Parseexpr(node);
            }

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsecompile_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.compile_stmt), "compile_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.COMPILE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.COMPILE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMPILE.ToString(), 0x1001, tok));
                return;
            }

            
            Parseexpr(node);

            
            tok = scanner.LookAhead(TokenType.TO);
            if (tok.Type == TokenType.TO)
            {

                
                tok = scanner.Scan(TokenType.TO);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.TO) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TO.ToString(), 0x1001, tok));
                    return;
                }

                
                Parseexpr(node);
            }

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parselist_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.list_stmt), "list_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.LIST);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LIST) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LIST.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.IDENTIFIER);
            if (tok.Type == TokenType.IDENTIFIER)
            {

                
                tok = scanner.Scan(TokenType.IDENTIFIER);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.IDENTIFIER) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                    return;
                }

                
                tok = scanner.LookAhead(TokenType.IN);
                if (tok.Type == TokenType.IN)
                {

                    
                    tok = scanner.Scan(TokenType.IN);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IN) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IN.ToString(), 0x1001, tok));
                        return;
                    }

                    
                    tok = scanner.Scan(TokenType.IDENTIFIER);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IDENTIFIER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                        return;
                    }
                }
            }

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsereboot_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.reboot_stmt), "reboot_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.REBOOT);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.REBOOT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.REBOOT.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseshutdown_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.shutdown_stmt), "shutdown_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.SHUTDOWN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SHUTDOWN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SHUTDOWN.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsefor_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.for_stmt), "for_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.FOR);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.FOR) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOR.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.IN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IN.ToString(), 0x1001, tok));
                return;
            }

            
            Parsevaridentifier(node);

            
            Parseinstruction(node);

            
            tok = scanner.LookAhead(TokenType.EOI);
            if (tok.Type == TokenType.EOI)
            {
                tok = scanner.Scan(TokenType.EOI);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.EOI) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseunset_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.unset_stmt), "unset_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.UNSET);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.UNSET) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.UNSET.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.IDENTIFIER, TokenType.ALL);
            switch (tok.Type)
            {
                case TokenType.IDENTIFIER:
                    tok = scanner.Scan(TokenType.IDENTIFIER);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IDENTIFIER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.ALL:
                    tok = scanner.Scan(TokenType.ALL);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.ALL) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ALL.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                    break;
            }

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsearglist(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.arglist), "arglist");
            parent.Nodes.Add(node);


            
            Parseexpr(node);

            
            tok = scanner.LookAhead(TokenType.COMMA);
            while (tok.Type == TokenType.COMMA)
            {

                
                tok = scanner.Scan(TokenType.COMMA);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, tok));
                    return;
                }

                
                Parseexpr(node);
            tok = scanner.LookAhead(TokenType.COMMA);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseexpr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.expr), "expr");
            parent.Nodes.Add(node);


            
            Parseand_expr(node);

            
            tok = scanner.LookAhead(TokenType.OR);
            while (tok.Type == TokenType.OR)
            {

                
                tok = scanner.Scan(TokenType.OR);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.OR) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OR.ToString(), 0x1001, tok));
                    return;
                }

                
                Parseand_expr(node);
            tok = scanner.LookAhead(TokenType.OR);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseand_expr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.and_expr), "and_expr");
            parent.Nodes.Add(node);


            
            Parsecompare_expr(node);

            
            tok = scanner.LookAhead(TokenType.AND);
            while (tok.Type == TokenType.AND)
            {

                
                tok = scanner.Scan(TokenType.AND);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.AND) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.AND.ToString(), 0x1001, tok));
                    return;
                }

                
                Parsecompare_expr(node);
            tok = scanner.LookAhead(TokenType.AND);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsecompare_expr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.compare_expr), "compare_expr");
            parent.Nodes.Add(node);


            
            Parsearith_expr(node);

            
            tok = scanner.LookAhead(TokenType.COMPARATOR);
            while (tok.Type == TokenType.COMPARATOR)
            {

                
                tok = scanner.Scan(TokenType.COMPARATOR);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMPARATOR) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMPARATOR.ToString(), 0x1001, tok));
                    return;
                }

                
                Parsearith_expr(node);
            tok = scanner.LookAhead(TokenType.COMPARATOR);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsearith_expr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.arith_expr), "arith_expr");
            parent.Nodes.Add(node);


            
            Parsemultdiv_expr(node);

            
            tok = scanner.LookAhead(TokenType.PLUSMINUS);
            while (tok.Type == TokenType.PLUSMINUS)
            {

                
                tok = scanner.Scan(TokenType.PLUSMINUS);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.PLUSMINUS) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PLUSMINUS.ToString(), 0x1001, tok));
                    return;
                }

                
                Parsemultdiv_expr(node);
            tok = scanner.LookAhead(TokenType.PLUSMINUS);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsemultdiv_expr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.multdiv_expr), "multdiv_expr");
            parent.Nodes.Add(node);


            
            Parseunary_expr(node);

            
            tok = scanner.LookAhead(TokenType.MULT, TokenType.DIV);
            while (tok.Type == TokenType.MULT
                || tok.Type == TokenType.DIV)
            {

                
                tok = scanner.LookAhead(TokenType.MULT, TokenType.DIV);
                switch (tok.Type)
                {
                    case TokenType.MULT:
                        tok = scanner.Scan(TokenType.MULT);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.MULT) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MULT.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    case TokenType.DIV:
                        tok = scanner.Scan(TokenType.DIV);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.DIV) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DIV.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                        break;
                }

                
                Parseunary_expr(node);
            tok = scanner.LookAhead(TokenType.MULT, TokenType.DIV);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseunary_expr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.unary_expr), "unary_expr");
            parent.Nodes.Add(node);


            
            tok = scanner.LookAhead(TokenType.PLUSMINUS, TokenType.NOT);
            if (tok.Type == TokenType.PLUSMINUS
                || tok.Type == TokenType.NOT)
            {
                tok = scanner.LookAhead(TokenType.PLUSMINUS, TokenType.NOT);
                switch (tok.Type)
                {
                    case TokenType.PLUSMINUS:
                        tok = scanner.Scan(TokenType.PLUSMINUS);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.PLUSMINUS) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PLUSMINUS.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    case TokenType.NOT:
                        tok = scanner.Scan(TokenType.NOT);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.NOT) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NOT.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                        break;
                }
            }

            
            Parsefactor(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsefactor(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.factor), "factor");
            parent.Nodes.Add(node);


            
            Parsesuffix(node);

            
            tok = scanner.LookAhead(TokenType.POWER);
            while (tok.Type == TokenType.POWER)
            {

                
                tok = scanner.Scan(TokenType.POWER);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.POWER) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.POWER.ToString(), 0x1001, tok));
                    return;
                }

                
                Parsesuffix(node);
            tok = scanner.LookAhead(TokenType.POWER);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsesuffix(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.suffix), "suffix");
            parent.Nodes.Add(node);


            
            Parsesuffixterm(node);

            
            tok = scanner.LookAhead(TokenType.COLON);
            while (tok.Type == TokenType.COLON)
            {
                Parsesuffix_trailer(node);
            tok = scanner.LookAhead(TokenType.COLON);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsesuffix_trailer(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.suffix_trailer), "suffix_trailer");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.COLON);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.COLON) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLON.ToString(), 0x1001, tok));
                return;
            }

            
            Parsesuffixterm(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsesuffixterm(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.suffixterm), "suffixterm");
            parent.Nodes.Add(node);


            
            Parseatom(node);

            
            tok = scanner.LookAhead(TokenType.BRACKETOPEN, TokenType.ARRAYINDEX, TokenType.SQUAREOPEN);
            while (tok.Type == TokenType.BRACKETOPEN
                || tok.Type == TokenType.ARRAYINDEX
                || tok.Type == TokenType.SQUAREOPEN)
            {
                Parsesuffixterm_trailer(node);
            tok = scanner.LookAhead(TokenType.BRACKETOPEN, TokenType.ARRAYINDEX, TokenType.SQUAREOPEN);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsesuffixterm_trailer(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.suffixterm_trailer), "suffixterm_trailer");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.BRACKETOPEN, TokenType.ARRAYINDEX, TokenType.SQUAREOPEN);
            switch (tok.Type)
            {
                case TokenType.BRACKETOPEN:
                    Parsefunction_trailer(node);
                    break;
                case TokenType.ARRAYINDEX:
                case TokenType.SQUAREOPEN:
                    Parsearray_trailer(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsefunction_trailer(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.function_trailer), "function_trailer");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.BRACKETOPEN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BRACKETOPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.PLUSMINUS, TokenType.NOT, TokenType.INTEGER, TokenType.DOUBLE, TokenType.TRUEFALSE, TokenType.IDENTIFIER, TokenType.FILEIDENT, TokenType.BRACKETOPEN, TokenType.STRING);
            if (tok.Type == TokenType.PLUSMINUS
                || tok.Type == TokenType.NOT
                || tok.Type == TokenType.INTEGER
                || tok.Type == TokenType.DOUBLE
                || tok.Type == TokenType.TRUEFALSE
                || tok.Type == TokenType.IDENTIFIER
                || tok.Type == TokenType.FILEIDENT
                || tok.Type == TokenType.BRACKETOPEN
                || tok.Type == TokenType.STRING)
            {
                Parsearglist(node);
            }

            
            tok = scanner.Scan(TokenType.BRACKETCLOSE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BRACKETCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsearray_trailer(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.array_trailer), "array_trailer");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.ARRAYINDEX, TokenType.SQUAREOPEN);
            switch (tok.Type)
            {
                case TokenType.ARRAYINDEX:

                    
                    tok = scanner.Scan(TokenType.ARRAYINDEX);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.ARRAYINDEX) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ARRAYINDEX.ToString(), 0x1001, tok));
                        return;
                    }

                    
                    tok = scanner.LookAhead(TokenType.IDENTIFIER, TokenType.INTEGER);
                    switch (tok.Type)
                    {
                        case TokenType.IDENTIFIER:
                            tok = scanner.Scan(TokenType.IDENTIFIER);
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.IDENTIFIER) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                                return;
                            }
                            break;
                        case TokenType.INTEGER:
                            tok = scanner.Scan(TokenType.INTEGER);
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.INTEGER) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INTEGER.ToString(), 0x1001, tok));
                                return;
                            }
                            break;
                        default:
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                            break;
                    }
                    break;
                case TokenType.SQUAREOPEN:

                    
                    tok = scanner.Scan(TokenType.SQUAREOPEN);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.SQUAREOPEN) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SQUAREOPEN.ToString(), 0x1001, tok));
                        return;
                    }

                    
                    Parseexpr(node);

                    
                    tok = scanner.Scan(TokenType.SQUARECLOSE);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.SQUARECLOSE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SQUARECLOSE.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseatom(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.atom), "atom");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.INTEGER, TokenType.DOUBLE, TokenType.TRUEFALSE, TokenType.IDENTIFIER, TokenType.FILEIDENT, TokenType.BRACKETOPEN, TokenType.STRING);
            switch (tok.Type)
            {
                case TokenType.INTEGER:
                case TokenType.DOUBLE:
                case TokenType.TRUEFALSE:
                case TokenType.IDENTIFIER:
                case TokenType.FILEIDENT:
                case TokenType.BRACKETOPEN:
                    tok = scanner.LookAhead(TokenType.INTEGER, TokenType.DOUBLE, TokenType.TRUEFALSE, TokenType.IDENTIFIER, TokenType.FILEIDENT, TokenType.BRACKETOPEN);
                    switch (tok.Type)
                    {
                        case TokenType.INTEGER:
                        case TokenType.DOUBLE:
                            Parsesci_number(node);
                            break;
                        case TokenType.TRUEFALSE:
                            tok = scanner.Scan(TokenType.TRUEFALSE);
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.TRUEFALSE) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TRUEFALSE.ToString(), 0x1001, tok));
                                return;
                            }
                            break;
                        case TokenType.IDENTIFIER:
                            tok = scanner.Scan(TokenType.IDENTIFIER);
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.IDENTIFIER) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                                return;
                            }
                            break;
                        case TokenType.FILEIDENT:
                            tok = scanner.Scan(TokenType.FILEIDENT);
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.FILEIDENT) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FILEIDENT.ToString(), 0x1001, tok));
                                return;
                            }
                            break;
                        case TokenType.BRACKETOPEN:

                            
                            tok = scanner.Scan(TokenType.BRACKETOPEN);
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.BRACKETOPEN) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString(), 0x1001, tok));
                                return;
                            }

                            
                            Parseexpr(node);

                            
                            tok = scanner.Scan(TokenType.BRACKETCLOSE);
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.BRACKETCLOSE) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString(), 0x1001, tok));
                                return;
                            }
                            break;
                        default:
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                            break;
                    }
                    break;
                case TokenType.STRING:
                    tok = scanner.Scan(TokenType.STRING);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.STRING) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsesci_number(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.sci_number), "sci_number");
            parent.Nodes.Add(node);


            
            Parsenumber(node);

            
            tok = scanner.LookAhead(TokenType.E);
            if (tok.Type == TokenType.E)
            {

                
                tok = scanner.Scan(TokenType.E);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.E) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.E.ToString(), 0x1001, tok));
                    return;
                }

                
                tok = scanner.LookAhead(TokenType.PLUSMINUS);
                if (tok.Type == TokenType.PLUSMINUS)
                {
                    tok = scanner.Scan(TokenType.PLUSMINUS);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.PLUSMINUS) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PLUSMINUS.ToString(), 0x1001, tok));
                        return;
                    }
                }

                
                tok = scanner.Scan(TokenType.INTEGER);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.INTEGER) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INTEGER.ToString(), 0x1001, tok));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsenumber(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.number), "number");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.INTEGER, TokenType.DOUBLE);
            switch (tok.Type)
            {
                case TokenType.INTEGER:
                    tok = scanner.Scan(TokenType.INTEGER);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.INTEGER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INTEGER.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.DOUBLE:
                    tok = scanner.Scan(TokenType.DOUBLE);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.DOUBLE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOUBLE.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsevaridentifier(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.varidentifier), "varidentifier");
            parent.Nodes.Add(node);

            Parsesuffix(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseidentifier_led_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.identifier_led_stmt), "identifier_led_stmt");
            parent.Nodes.Add(node);


            
            Parseidentifier_led_expr(node);

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseidentifier_led_expr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.identifier_led_expr), "identifier_led_expr");
            parent.Nodes.Add(node);


            
            Parsesuffix(node);

            
            tok = scanner.LookAhead(TokenType.ON, TokenType.OFF);
            if (tok.Type == TokenType.ON
                || tok.Type == TokenType.OFF)
            {
                Parseonoff_trailer(node);
            }

            parent.Token.UpdateRange(node.Token);
        }


    }

    #endregion Parser
}
