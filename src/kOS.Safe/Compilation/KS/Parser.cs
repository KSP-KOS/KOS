// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;

// Disable unused variable warnings which
// can happen during the parser generation.
#pragma warning disable 168

namespace kOS.Safe.Compilation.KS
{
    #region Parser

    public partial class Parser 
    {
        private Scanner scanner;
        private ParseTree tree;
        
        public Parser(Scanner scanner)
        {
            this.scanner = scanner;
        }

         public ParseTree Parse(string input)
        {
            return Parse(input, "", new ParseTree());
        }

        public ParseTree Parse(string input, string fileName)
        {
            return Parse(input, fileName, new ParseTree());
        }

        public ParseTree Parse(string input, string fileName, ParseTree tree)
        {
            scanner.Init(input, fileName);

            this.tree = tree;
            ParseStart(tree);
            tree.Skipped = scanner.Skipped;

            return tree;
        }

        private void ParseStart(ParseNode parent) // NonTerminalSymbol: Start
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Start), "Start");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.LookAhead(TokenType.EOI, TokenType.SET, TokenType.IF, TokenType.UNTIL, TokenType.FROM, TokenType.UNLOCK, TokenType.PRINT, TokenType.ON, TokenType.TOGGLE, TokenType.WAIT, TokenType.WHEN, TokenType.STAGE, TokenType.CLEARSCREEN, TokenType.ADD, TokenType.REMOVE, TokenType.LOG, TokenType.BREAK, TokenType.PRESERVE, TokenType.PARAMETER, TokenType.FUNCTION, TokenType.LOCK, TokenType.DECLARE, TokenType.LOCAL, TokenType.GLOBAL, TokenType.RETURN, TokenType.SWITCH, TokenType.COPY, TokenType.RENAME, TokenType.DELETE, TokenType.EDIT, TokenType.RUN, TokenType.RUNPATH, TokenType.RUNONCEPATH, TokenType.COMPILE, TokenType.LIST, TokenType.REBOOT, TokenType.SHUTDOWN, TokenType.FOR, TokenType.UNSET, TokenType.CURLYOPEN, TokenType.INTEGER, TokenType.DOUBLE, TokenType.TRUEFALSE, TokenType.IDENTIFIER, TokenType.FILEIDENT, TokenType.BRACKETOPEN, TokenType.STRING, TokenType.ATSIGN); // ZeroOrMore Rule
            while (tok.Type == TokenType.EOI
                || tok.Type == TokenType.SET
                || tok.Type == TokenType.IF
                || tok.Type == TokenType.UNTIL
                || tok.Type == TokenType.FROM
                || tok.Type == TokenType.UNLOCK
                || tok.Type == TokenType.PRINT
                || tok.Type == TokenType.ON
                || tok.Type == TokenType.TOGGLE
                || tok.Type == TokenType.WAIT
                || tok.Type == TokenType.WHEN
                || tok.Type == TokenType.STAGE
                || tok.Type == TokenType.CLEARSCREEN
                || tok.Type == TokenType.ADD
                || tok.Type == TokenType.REMOVE
                || tok.Type == TokenType.LOG
                || tok.Type == TokenType.BREAK
                || tok.Type == TokenType.PRESERVE
                || tok.Type == TokenType.PARAMETER
                || tok.Type == TokenType.FUNCTION
                || tok.Type == TokenType.LOCK
                || tok.Type == TokenType.DECLARE
                || tok.Type == TokenType.LOCAL
                || tok.Type == TokenType.GLOBAL
                || tok.Type == TokenType.RETURN
                || tok.Type == TokenType.SWITCH
                || tok.Type == TokenType.COPY
                || tok.Type == TokenType.RENAME
                || tok.Type == TokenType.DELETE
                || tok.Type == TokenType.EDIT
                || tok.Type == TokenType.RUN
                || tok.Type == TokenType.RUNPATH
                || tok.Type == TokenType.RUNONCEPATH
                || tok.Type == TokenType.COMPILE
                || tok.Type == TokenType.LIST
                || tok.Type == TokenType.REBOOT
                || tok.Type == TokenType.SHUTDOWN
                || tok.Type == TokenType.FOR
                || tok.Type == TokenType.UNSET
                || tok.Type == TokenType.CURLYOPEN
                || tok.Type == TokenType.INTEGER
                || tok.Type == TokenType.DOUBLE
                || tok.Type == TokenType.TRUEFALSE
                || tok.Type == TokenType.IDENTIFIER
                || tok.Type == TokenType.FILEIDENT
                || tok.Type == TokenType.BRACKETOPEN
                || tok.Type == TokenType.STRING
                || tok.Type == TokenType.ATSIGN)
            {
                Parseinstruction(node); // NonTerminal Rule: instruction
            tok = scanner.LookAhead(TokenType.EOI, TokenType.SET, TokenType.IF, TokenType.UNTIL, TokenType.FROM, TokenType.UNLOCK, TokenType.PRINT, TokenType.ON, TokenType.TOGGLE, TokenType.WAIT, TokenType.WHEN, TokenType.STAGE, TokenType.CLEARSCREEN, TokenType.ADD, TokenType.REMOVE, TokenType.LOG, TokenType.BREAK, TokenType.PRESERVE, TokenType.PARAMETER, TokenType.FUNCTION, TokenType.LOCK, TokenType.DECLARE, TokenType.LOCAL, TokenType.GLOBAL, TokenType.RETURN, TokenType.SWITCH, TokenType.COPY, TokenType.RENAME, TokenType.DELETE, TokenType.EDIT, TokenType.RUN, TokenType.RUNPATH, TokenType.RUNONCEPATH, TokenType.COMPILE, TokenType.LIST, TokenType.REBOOT, TokenType.SHUTDOWN, TokenType.FOR, TokenType.UNSET, TokenType.CURLYOPEN, TokenType.INTEGER, TokenType.DOUBLE, TokenType.TRUEFALSE, TokenType.IDENTIFIER, TokenType.FILEIDENT, TokenType.BRACKETOPEN, TokenType.STRING, TokenType.ATSIGN); // ZeroOrMore Rule
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.EOF); // Terminal Rule: EOF
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOF) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Start

        private void Parseinstruction_block(ParseNode parent) // NonTerminalSymbol: instruction_block
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.instruction_block), "instruction_block");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.CURLYOPEN); // Terminal Rule: CURLYOPEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CURLYOPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CURLYOPEN.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.EOI, TokenType.SET, TokenType.IF, TokenType.UNTIL, TokenType.FROM, TokenType.UNLOCK, TokenType.PRINT, TokenType.ON, TokenType.TOGGLE, TokenType.WAIT, TokenType.WHEN, TokenType.STAGE, TokenType.CLEARSCREEN, TokenType.ADD, TokenType.REMOVE, TokenType.LOG, TokenType.BREAK, TokenType.PRESERVE, TokenType.PARAMETER, TokenType.FUNCTION, TokenType.LOCK, TokenType.DECLARE, TokenType.LOCAL, TokenType.GLOBAL, TokenType.RETURN, TokenType.SWITCH, TokenType.COPY, TokenType.RENAME, TokenType.DELETE, TokenType.EDIT, TokenType.RUN, TokenType.RUNPATH, TokenType.RUNONCEPATH, TokenType.COMPILE, TokenType.LIST, TokenType.REBOOT, TokenType.SHUTDOWN, TokenType.FOR, TokenType.UNSET, TokenType.CURLYOPEN, TokenType.INTEGER, TokenType.DOUBLE, TokenType.TRUEFALSE, TokenType.IDENTIFIER, TokenType.FILEIDENT, TokenType.BRACKETOPEN, TokenType.STRING, TokenType.ATSIGN); // ZeroOrMore Rule
            while (tok.Type == TokenType.EOI
                || tok.Type == TokenType.SET
                || tok.Type == TokenType.IF
                || tok.Type == TokenType.UNTIL
                || tok.Type == TokenType.FROM
                || tok.Type == TokenType.UNLOCK
                || tok.Type == TokenType.PRINT
                || tok.Type == TokenType.ON
                || tok.Type == TokenType.TOGGLE
                || tok.Type == TokenType.WAIT
                || tok.Type == TokenType.WHEN
                || tok.Type == TokenType.STAGE
                || tok.Type == TokenType.CLEARSCREEN
                || tok.Type == TokenType.ADD
                || tok.Type == TokenType.REMOVE
                || tok.Type == TokenType.LOG
                || tok.Type == TokenType.BREAK
                || tok.Type == TokenType.PRESERVE
                || tok.Type == TokenType.PARAMETER
                || tok.Type == TokenType.FUNCTION
                || tok.Type == TokenType.LOCK
                || tok.Type == TokenType.DECLARE
                || tok.Type == TokenType.LOCAL
                || tok.Type == TokenType.GLOBAL
                || tok.Type == TokenType.RETURN
                || tok.Type == TokenType.SWITCH
                || tok.Type == TokenType.COPY
                || tok.Type == TokenType.RENAME
                || tok.Type == TokenType.DELETE
                || tok.Type == TokenType.EDIT
                || tok.Type == TokenType.RUN
                || tok.Type == TokenType.RUNPATH
                || tok.Type == TokenType.RUNONCEPATH
                || tok.Type == TokenType.COMPILE
                || tok.Type == TokenType.LIST
                || tok.Type == TokenType.REBOOT
                || tok.Type == TokenType.SHUTDOWN
                || tok.Type == TokenType.FOR
                || tok.Type == TokenType.UNSET
                || tok.Type == TokenType.CURLYOPEN
                || tok.Type == TokenType.INTEGER
                || tok.Type == TokenType.DOUBLE
                || tok.Type == TokenType.TRUEFALSE
                || tok.Type == TokenType.IDENTIFIER
                || tok.Type == TokenType.FILEIDENT
                || tok.Type == TokenType.BRACKETOPEN
                || tok.Type == TokenType.STRING
                || tok.Type == TokenType.ATSIGN)
            {
                Parseinstruction(node); // NonTerminal Rule: instruction
            tok = scanner.LookAhead(TokenType.EOI, TokenType.SET, TokenType.IF, TokenType.UNTIL, TokenType.FROM, TokenType.UNLOCK, TokenType.PRINT, TokenType.ON, TokenType.TOGGLE, TokenType.WAIT, TokenType.WHEN, TokenType.STAGE, TokenType.CLEARSCREEN, TokenType.ADD, TokenType.REMOVE, TokenType.LOG, TokenType.BREAK, TokenType.PRESERVE, TokenType.PARAMETER, TokenType.FUNCTION, TokenType.LOCK, TokenType.DECLARE, TokenType.LOCAL, TokenType.GLOBAL, TokenType.RETURN, TokenType.SWITCH, TokenType.COPY, TokenType.RENAME, TokenType.DELETE, TokenType.EDIT, TokenType.RUN, TokenType.RUNPATH, TokenType.RUNONCEPATH, TokenType.COMPILE, TokenType.LIST, TokenType.REBOOT, TokenType.SHUTDOWN, TokenType.FOR, TokenType.UNSET, TokenType.CURLYOPEN, TokenType.INTEGER, TokenType.DOUBLE, TokenType.TRUEFALSE, TokenType.IDENTIFIER, TokenType.FILEIDENT, TokenType.BRACKETOPEN, TokenType.STRING, TokenType.ATSIGN); // ZeroOrMore Rule
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.CURLYCLOSE); // Terminal Rule: CURLYCLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CURLYCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CURLYCLOSE.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: instruction_block

        private void Parseinstruction(ParseNode parent) // NonTerminalSymbol: instruction
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.instruction), "instruction");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.EOI, TokenType.SET, TokenType.IF, TokenType.UNTIL, TokenType.FROM, TokenType.UNLOCK, TokenType.PRINT, TokenType.ON, TokenType.TOGGLE, TokenType.WAIT, TokenType.WHEN, TokenType.STAGE, TokenType.CLEARSCREEN, TokenType.ADD, TokenType.REMOVE, TokenType.LOG, TokenType.BREAK, TokenType.PRESERVE, TokenType.PARAMETER, TokenType.FUNCTION, TokenType.LOCK, TokenType.DECLARE, TokenType.LOCAL, TokenType.GLOBAL, TokenType.RETURN, TokenType.SWITCH, TokenType.COPY, TokenType.RENAME, TokenType.DELETE, TokenType.EDIT, TokenType.RUN, TokenType.RUNPATH, TokenType.RUNONCEPATH, TokenType.COMPILE, TokenType.LIST, TokenType.REBOOT, TokenType.SHUTDOWN, TokenType.FOR, TokenType.UNSET, TokenType.CURLYOPEN, TokenType.INTEGER, TokenType.DOUBLE, TokenType.TRUEFALSE, TokenType.IDENTIFIER, TokenType.FILEIDENT, TokenType.BRACKETOPEN, TokenType.STRING, TokenType.ATSIGN); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.EOI:
                    Parseempty_stmt(node); // NonTerminal Rule: empty_stmt
                    break;
                case TokenType.SET:
                    Parseset_stmt(node); // NonTerminal Rule: set_stmt
                    break;
                case TokenType.IF:
                    Parseif_stmt(node); // NonTerminal Rule: if_stmt
                    break;
                case TokenType.UNTIL:
                    Parseuntil_stmt(node); // NonTerminal Rule: until_stmt
                    break;
                case TokenType.FROM:
                    Parsefromloop_stmt(node); // NonTerminal Rule: fromloop_stmt
                    break;
                case TokenType.UNLOCK:
                    Parseunlock_stmt(node); // NonTerminal Rule: unlock_stmt
                    break;
                case TokenType.PRINT:
                    Parseprint_stmt(node); // NonTerminal Rule: print_stmt
                    break;
                case TokenType.ON:
                    Parseon_stmt(node); // NonTerminal Rule: on_stmt
                    break;
                case TokenType.TOGGLE:
                    Parsetoggle_stmt(node); // NonTerminal Rule: toggle_stmt
                    break;
                case TokenType.WAIT:
                    Parsewait_stmt(node); // NonTerminal Rule: wait_stmt
                    break;
                case TokenType.WHEN:
                    Parsewhen_stmt(node); // NonTerminal Rule: when_stmt
                    break;
                case TokenType.STAGE:
                    Parsestage_stmt(node); // NonTerminal Rule: stage_stmt
                    break;
                case TokenType.CLEARSCREEN:
                    Parseclear_stmt(node); // NonTerminal Rule: clear_stmt
                    break;
                case TokenType.ADD:
                    Parseadd_stmt(node); // NonTerminal Rule: add_stmt
                    break;
                case TokenType.REMOVE:
                    Parseremove_stmt(node); // NonTerminal Rule: remove_stmt
                    break;
                case TokenType.LOG:
                    Parselog_stmt(node); // NonTerminal Rule: log_stmt
                    break;
                case TokenType.BREAK:
                    Parsebreak_stmt(node); // NonTerminal Rule: break_stmt
                    break;
                case TokenType.PRESERVE:
                    Parsepreserve_stmt(node); // NonTerminal Rule: preserve_stmt
                    break;
                case TokenType.PARAMETER:
                case TokenType.FUNCTION:
                case TokenType.LOCK:
                case TokenType.DECLARE:
                case TokenType.LOCAL:
                case TokenType.GLOBAL:
                    Parsedeclare_stmt(node); // NonTerminal Rule: declare_stmt
                    break;
                case TokenType.RETURN:
                    Parsereturn_stmt(node); // NonTerminal Rule: return_stmt
                    break;
                case TokenType.SWITCH:
                    Parseswitch_stmt(node); // NonTerminal Rule: switch_stmt
                    break;
                case TokenType.COPY:
                    Parsecopy_stmt(node); // NonTerminal Rule: copy_stmt
                    break;
                case TokenType.RENAME:
                    Parserename_stmt(node); // NonTerminal Rule: rename_stmt
                    break;
                case TokenType.DELETE:
                    Parsedelete_stmt(node); // NonTerminal Rule: delete_stmt
                    break;
                case TokenType.EDIT:
                    Parseedit_stmt(node); // NonTerminal Rule: edit_stmt
                    break;
                case TokenType.RUN:
                    Parserun_stmt(node); // NonTerminal Rule: run_stmt
                    break;
                case TokenType.RUNPATH:
                    Parserunpath_stmt(node); // NonTerminal Rule: runpath_stmt
                    break;
                case TokenType.RUNONCEPATH:
                    Parserunoncepath_stmt(node); // NonTerminal Rule: runoncepath_stmt
                    break;
                case TokenType.COMPILE:
                    Parsecompile_stmt(node); // NonTerminal Rule: compile_stmt
                    break;
                case TokenType.LIST:
                    Parselist_stmt(node); // NonTerminal Rule: list_stmt
                    break;
                case TokenType.REBOOT:
                    Parsereboot_stmt(node); // NonTerminal Rule: reboot_stmt
                    break;
                case TokenType.SHUTDOWN:
                    Parseshutdown_stmt(node); // NonTerminal Rule: shutdown_stmt
                    break;
                case TokenType.FOR:
                    Parsefor_stmt(node); // NonTerminal Rule: for_stmt
                    break;
                case TokenType.UNSET:
                    Parseunset_stmt(node); // NonTerminal Rule: unset_stmt
                    break;
                case TokenType.CURLYOPEN:
                    Parseinstruction_block(node); // NonTerminal Rule: instruction_block
                    break;
                case TokenType.INTEGER:
                case TokenType.DOUBLE:
                case TokenType.TRUEFALSE:
                case TokenType.IDENTIFIER:
                case TokenType.FILEIDENT:
                case TokenType.BRACKETOPEN:
                case TokenType.STRING:
                    Parseidentifier_led_stmt(node); // NonTerminal Rule: identifier_led_stmt
                    break;
                case TokenType.ATSIGN:
                    Parsedirective(node); // NonTerminal Rule: directive
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected EOI, SET, IF, UNTIL, FROM, UNLOCK, PRINT, ON, TOGGLE, WAIT, WHEN, STAGE, CLEARSCREEN, ADD, REMOVE, LOG, BREAK, PRESERVE, PARAMETER, FUNCTION, LOCK, DECLARE, LOCAL, GLOBAL, RETURN, SWITCH, COPY, RENAME, DELETE, EDIT, RUN, RUNPATH, RUNONCEPATH, COMPILE, LIST, REBOOT, SHUTDOWN, FOR, UNSET, CURLYOPEN, INTEGER, DOUBLE, TRUEFALSE, IDENTIFIER, FILEIDENT, BRACKETOPEN, STRING, or ATSIGN.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: instruction

        private void Parselazyglobal_directive(ParseNode parent) // NonTerminalSymbol: lazyglobal_directive
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.lazyglobal_directive), "lazyglobal_directive");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.ATSIGN); // Terminal Rule: ATSIGN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ATSIGN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ATSIGN.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.LAZYGLOBAL); // Terminal Rule: LAZYGLOBAL
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LAZYGLOBAL) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LAZYGLOBAL.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parseonoff_trailer(node); // NonTerminal Rule: onoff_trailer

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: lazyglobal_directive

        private void Parsedirective(ParseNode parent) // NonTerminalSymbol: directive
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.directive), "directive");
            parent.Nodes.Add(node);

            Parselazyglobal_directive(node); // NonTerminal Rule: lazyglobal_directive

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: directive

        private void Parseempty_stmt(ParseNode parent) // NonTerminalSymbol: empty_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.empty_stmt), "empty_stmt");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: empty_stmt

        private void Parseset_stmt(ParseNode parent) // NonTerminalSymbol: set_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.set_stmt), "set_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.SET); // Terminal Rule: SET
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SET) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SET.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parsevaridentifier(node); // NonTerminal Rule: varidentifier

             // Concat Rule
            tok = scanner.Scan(TokenType.TO); // Terminal Rule: TO
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TO.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parseexpr(node); // NonTerminal Rule: expr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
            while (tok.Type == TokenType.COMMA)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.COMMA); // Terminal Rule: COMMA
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                Parsevaridentifier(node); // NonTerminal Rule: varidentifier

                 // Concat Rule
                tok = scanner.Scan(TokenType.TO); // Terminal Rule: TO
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.TO) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TO.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                Parseexpr(node); // NonTerminal Rule: expr
            tok = scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: set_stmt

        private void Parseif_stmt(ParseNode parent) // NonTerminalSymbol: if_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.if_stmt), "if_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.IF); // Terminal Rule: IF
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IF) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IF.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parseexpr(node); // NonTerminal Rule: expr

             // Concat Rule
            Parseinstruction(node); // NonTerminal Rule: instruction

             // Concat Rule
            tok = scanner.LookAhead(TokenType.EOI); // Option Rule
            if (tok.Type == TokenType.EOI)
            {
                tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.EOI) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                    return;
                }
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.ELSE); // Option Rule
            if (tok.Type == TokenType.ELSE)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.ELSE); // Terminal Rule: ELSE
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.ELSE) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ELSE.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                Parseinstruction(node); // NonTerminal Rule: instruction

                 // Concat Rule
                tok = scanner.LookAhead(TokenType.EOI); // Option Rule
                if (tok.Type == TokenType.EOI)
                {
                    tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.EOI) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                        return;
                    }
                }
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: if_stmt

        private void Parseuntil_stmt(ParseNode parent) // NonTerminalSymbol: until_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.until_stmt), "until_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.UNTIL); // Terminal Rule: UNTIL
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.UNTIL) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.UNTIL.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parseexpr(node); // NonTerminal Rule: expr

             // Concat Rule
            Parseinstruction(node); // NonTerminal Rule: instruction

             // Concat Rule
            tok = scanner.LookAhead(TokenType.EOI); // Option Rule
            if (tok.Type == TokenType.EOI)
            {
                tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.EOI) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: until_stmt

        private void Parsefromloop_stmt(ParseNode parent) // NonTerminalSymbol: fromloop_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.fromloop_stmt), "fromloop_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.FROM); // Terminal Rule: FROM
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.FROM) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FROM.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parseinstruction_block(node); // NonTerminal Rule: instruction_block

             // Concat Rule
            tok = scanner.Scan(TokenType.UNTIL); // Terminal Rule: UNTIL
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.UNTIL) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.UNTIL.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parseexpr(node); // NonTerminal Rule: expr

             // Concat Rule
            tok = scanner.Scan(TokenType.STEP); // Terminal Rule: STEP
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.STEP) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STEP.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parseinstruction_block(node); // NonTerminal Rule: instruction_block

             // Concat Rule
            tok = scanner.Scan(TokenType.DO); // Terminal Rule: DO
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.DO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DO.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parseinstruction(node); // NonTerminal Rule: instruction

             // Concat Rule
            tok = scanner.LookAhead(TokenType.EOI); // Option Rule
            if (tok.Type == TokenType.EOI)
            {
                tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.EOI) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: fromloop_stmt

        private void Parseunlock_stmt(ParseNode parent) // NonTerminalSymbol: unlock_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.unlock_stmt), "unlock_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.UNLOCK); // Terminal Rule: UNLOCK
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.UNLOCK) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.UNLOCK.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.IDENTIFIER, TokenType.ALL); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.IDENTIFIER:
                    tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IDENTIFIER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.ALL:
                    tok = scanner.Scan(TokenType.ALL); // Terminal Rule: ALL
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.ALL) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ALL.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected IDENTIFIER or ALL.", 0x0002, tok));
                    break;
            } // Choice Rule

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: unlock_stmt

        private void Parseprint_stmt(ParseNode parent) // NonTerminalSymbol: print_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.print_stmt), "print_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.PRINT); // Terminal Rule: PRINT
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PRINT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PRINT.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parseexpr(node); // NonTerminal Rule: expr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.AT); // Option Rule
            if (tok.Type == TokenType.AT)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.AT); // Terminal Rule: AT
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.AT) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.AT.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                tok = scanner.Scan(TokenType.BRACKETOPEN); // Terminal Rule: BRACKETOPEN
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.BRACKETOPEN) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                Parseexpr(node); // NonTerminal Rule: expr

                 // Concat Rule
                tok = scanner.Scan(TokenType.COMMA); // Terminal Rule: COMMA
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                Parseexpr(node); // NonTerminal Rule: expr

                 // Concat Rule
                tok = scanner.Scan(TokenType.BRACKETCLOSE); // Terminal Rule: BRACKETCLOSE
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.BRACKETCLOSE) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString(), 0x1001, tok));
                    return;
                }
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: print_stmt

        private void Parseon_stmt(ParseNode parent) // NonTerminalSymbol: on_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.on_stmt), "on_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.ON); // Terminal Rule: ON
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ON) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ON.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parsevaridentifier(node); // NonTerminal Rule: varidentifier

             // Concat Rule
            Parseinstruction(node); // NonTerminal Rule: instruction

             // Concat Rule
            tok = scanner.LookAhead(TokenType.EOI); // Option Rule
            if (tok.Type == TokenType.EOI)
            {
                tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.EOI) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: on_stmt

        private void Parsetoggle_stmt(ParseNode parent) // NonTerminalSymbol: toggle_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.toggle_stmt), "toggle_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.TOGGLE); // Terminal Rule: TOGGLE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TOGGLE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TOGGLE.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parsevaridentifier(node); // NonTerminal Rule: varidentifier

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: toggle_stmt

        private void Parsewait_stmt(ParseNode parent) // NonTerminalSymbol: wait_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.wait_stmt), "wait_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.WAIT); // Terminal Rule: WAIT
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.WAIT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WAIT.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.UNTIL); // Option Rule
            if (tok.Type == TokenType.UNTIL)
            {
                tok = scanner.Scan(TokenType.UNTIL); // Terminal Rule: UNTIL
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.UNTIL) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.UNTIL.ToString(), 0x1001, tok));
                    return;
                }
            }

             // Concat Rule
            Parseexpr(node); // NonTerminal Rule: expr

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: wait_stmt

        private void Parsewhen_stmt(ParseNode parent) // NonTerminalSymbol: when_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.when_stmt), "when_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.WHEN); // Terminal Rule: WHEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.WHEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WHEN.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parseexpr(node); // NonTerminal Rule: expr

             // Concat Rule
            tok = scanner.Scan(TokenType.THEN); // Terminal Rule: THEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.THEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.THEN.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parseinstruction(node); // NonTerminal Rule: instruction

             // Concat Rule
            tok = scanner.LookAhead(TokenType.EOI); // Option Rule
            if (tok.Type == TokenType.EOI)
            {
                tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.EOI) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: when_stmt

        private void Parseonoff_stmt(ParseNode parent) // NonTerminalSymbol: onoff_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.onoff_stmt), "onoff_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            Parsevaridentifier(node); // NonTerminal Rule: varidentifier

             // Concat Rule
            Parseonoff_trailer(node); // NonTerminal Rule: onoff_trailer

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: onoff_stmt

        private void Parseonoff_trailer(ParseNode parent) // NonTerminalSymbol: onoff_trailer
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.onoff_trailer), "onoff_trailer");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.ON, TokenType.OFF); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.ON:
                    tok = scanner.Scan(TokenType.ON); // Terminal Rule: ON
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.ON) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ON.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.OFF:
                    tok = scanner.Scan(TokenType.OFF); // Terminal Rule: OFF
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.OFF) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OFF.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected ON or OFF.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: onoff_trailer

        private void Parsestage_stmt(ParseNode parent) // NonTerminalSymbol: stage_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.stage_stmt), "stage_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.STAGE); // Terminal Rule: STAGE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.STAGE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STAGE.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: stage_stmt

        private void Parseclear_stmt(ParseNode parent) // NonTerminalSymbol: clear_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.clear_stmt), "clear_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.CLEARSCREEN); // Terminal Rule: CLEARSCREEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CLEARSCREEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CLEARSCREEN.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: clear_stmt

        private void Parseadd_stmt(ParseNode parent) // NonTerminalSymbol: add_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.add_stmt), "add_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.ADD); // Terminal Rule: ADD
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ADD) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ADD.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parseexpr(node); // NonTerminal Rule: expr

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: add_stmt

        private void Parseremove_stmt(ParseNode parent) // NonTerminalSymbol: remove_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.remove_stmt), "remove_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.REMOVE); // Terminal Rule: REMOVE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.REMOVE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.REMOVE.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parseexpr(node); // NonTerminal Rule: expr

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: remove_stmt

        private void Parselog_stmt(ParseNode parent) // NonTerminalSymbol: log_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.log_stmt), "log_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.LOG); // Terminal Rule: LOG
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LOG) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LOG.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parseexpr(node); // NonTerminal Rule: expr

             // Concat Rule
            tok = scanner.Scan(TokenType.TO); // Terminal Rule: TO
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TO.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parseexpr(node); // NonTerminal Rule: expr

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: log_stmt

        private void Parsebreak_stmt(ParseNode parent) // NonTerminalSymbol: break_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.break_stmt), "break_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.BREAK); // Terminal Rule: BREAK
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BREAK) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BREAK.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: break_stmt

        private void Parsepreserve_stmt(ParseNode parent) // NonTerminalSymbol: preserve_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.preserve_stmt), "preserve_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.PRESERVE); // Terminal Rule: PRESERVE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PRESERVE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PRESERVE.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: preserve_stmt

        private void Parsedeclare_identifier_clause(ParseNode parent) // NonTerminalSymbol: declare_identifier_clause
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.declare_identifier_clause), "declare_identifier_clause");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.TO, TokenType.IS); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.TO:
                    tok = scanner.Scan(TokenType.TO); // Terminal Rule: TO
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.TO) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TO.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.IS:
                    tok = scanner.Scan(TokenType.IS); // Terminal Rule: IS
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IS) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IS.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected TO or IS.", 0x0002, tok));
                    break;
            } // Choice Rule

             // Concat Rule
            Parseexpr(node); // NonTerminal Rule: expr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
            while (tok.Type == TokenType.COMMA)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.COMMA); // Terminal Rule: COMMA
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.IDENTIFIER) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                tok = scanner.LookAhead(TokenType.TO, TokenType.IS); // Choice Rule
                switch (tok.Type)
                { // Choice Rule
                    case TokenType.TO:
                        tok = scanner.Scan(TokenType.TO); // Terminal Rule: TO
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.TO) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TO.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    case TokenType.IS:
                        tok = scanner.Scan(TokenType.IS); // Terminal Rule: IS
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.IS) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IS.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected TO or IS.", 0x0002, tok));
                        break;
                } // Choice Rule

                 // Concat Rule
                Parseexpr(node); // NonTerminal Rule: expr
            tok = scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: declare_identifier_clause

        private void Parsedeclare_parameter_clause(ParseNode parent) // NonTerminalSymbol: declare_parameter_clause
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.declare_parameter_clause), "declare_parameter_clause");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.PARAMETER); // Terminal Rule: PARAMETER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PARAMETER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PARAMETER.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.TO, TokenType.IS); // Option Rule
            if (tok.Type == TokenType.TO
                || tok.Type == TokenType.IS)
            {

                 // Concat Rule
                tok = scanner.LookAhead(TokenType.TO, TokenType.IS); // Choice Rule
                switch (tok.Type)
                { // Choice Rule
                    case TokenType.TO:
                        tok = scanner.Scan(TokenType.TO); // Terminal Rule: TO
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.TO) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TO.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    case TokenType.IS:
                        tok = scanner.Scan(TokenType.IS); // Terminal Rule: IS
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.IS) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IS.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected TO or IS.", 0x0002, tok));
                        break;
                } // Choice Rule

                 // Concat Rule
                Parseexpr(node); // NonTerminal Rule: expr
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
            while (tok.Type == TokenType.COMMA)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.COMMA); // Terminal Rule: COMMA
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.IDENTIFIER) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                tok = scanner.LookAhead(TokenType.TO, TokenType.IS); // Option Rule
                if (tok.Type == TokenType.TO
                    || tok.Type == TokenType.IS)
                {

                     // Concat Rule
                    tok = scanner.LookAhead(TokenType.TO, TokenType.IS); // Choice Rule
                    switch (tok.Type)
                    { // Choice Rule
                        case TokenType.TO:
                            tok = scanner.Scan(TokenType.TO); // Terminal Rule: TO
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.TO) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TO.ToString(), 0x1001, tok));
                                return;
                            }
                            break;
                        case TokenType.IS:
                            tok = scanner.Scan(TokenType.IS); // Terminal Rule: IS
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.IS) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IS.ToString(), 0x1001, tok));
                                return;
                            }
                            break;
                        default:
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected TO or IS.", 0x0002, tok));
                            break;
                    } // Choice Rule

                     // Concat Rule
                    Parseexpr(node); // NonTerminal Rule: expr
                }
            tok = scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: declare_parameter_clause

        private void Parsedeclare_function_clause(ParseNode parent) // NonTerminalSymbol: declare_function_clause
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.declare_function_clause), "declare_function_clause");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.FUNCTION); // Terminal Rule: FUNCTION
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.FUNCTION) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FUNCTION.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parseinstruction_block(node); // NonTerminal Rule: instruction_block

             // Concat Rule
            tok = scanner.LookAhead(TokenType.EOI); // Option Rule
            if (tok.Type == TokenType.EOI)
            {
                tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.EOI) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: declare_function_clause

        private void Parsedeclare_lock_clause(ParseNode parent) // NonTerminalSymbol: declare_lock_clause
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.declare_lock_clause), "declare_lock_clause");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.LOCK); // Terminal Rule: LOCK
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LOCK) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LOCK.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.TO); // Terminal Rule: TO
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TO.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parseexpr(node); // NonTerminal Rule: expr

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: declare_lock_clause

        private void Parsedeclare_stmt(ParseNode parent) // NonTerminalSymbol: declare_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.declare_stmt), "declare_stmt");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.PARAMETER, TokenType.FUNCTION, TokenType.LOCK, TokenType.DECLARE, TokenType.LOCAL, TokenType.GLOBAL); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.PARAMETER:
                    Parsedeclare_parameter_clause(node); // NonTerminal Rule: declare_parameter_clause
                    break;
                case TokenType.FUNCTION:
                    Parsedeclare_function_clause(node); // NonTerminal Rule: declare_function_clause
                    break;
                case TokenType.LOCK:
                    Parsedeclare_lock_clause(node); // NonTerminal Rule: declare_lock_clause
                    break;
                case TokenType.DECLARE:
                case TokenType.LOCAL:
                case TokenType.GLOBAL:

                     // Concat Rule
                    tok = scanner.LookAhead(TokenType.DECLARE, TokenType.LOCAL, TokenType.GLOBAL); // Choice Rule
                    switch (tok.Type)
                    { // Choice Rule
                        case TokenType.DECLARE:

                             // Concat Rule
                            tok = scanner.Scan(TokenType.DECLARE); // Terminal Rule: DECLARE
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.DECLARE) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DECLARE.ToString(), 0x1001, tok));
                                return;
                            }

                             // Concat Rule
                            tok = scanner.LookAhead(TokenType.LOCAL, TokenType.GLOBAL); // Option Rule
                            if (tok.Type == TokenType.LOCAL
                                || tok.Type == TokenType.GLOBAL)
                            {
                                tok = scanner.LookAhead(TokenType.LOCAL, TokenType.GLOBAL); // Choice Rule
                                switch (tok.Type)
                                { // Choice Rule
                                    case TokenType.LOCAL:
                                        tok = scanner.Scan(TokenType.LOCAL); // Terminal Rule: LOCAL
                                        n = node.CreateNode(tok, tok.ToString() );
                                        node.Token.UpdateRange(tok);
                                        node.Nodes.Add(n);
                                        if (tok.Type != TokenType.LOCAL) {
                                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LOCAL.ToString(), 0x1001, tok));
                                            return;
                                        }
                                        break;
                                    case TokenType.GLOBAL:
                                        tok = scanner.Scan(TokenType.GLOBAL); // Terminal Rule: GLOBAL
                                        n = node.CreateNode(tok, tok.ToString() );
                                        node.Token.UpdateRange(tok);
                                        node.Nodes.Add(n);
                                        if (tok.Type != TokenType.GLOBAL) {
                                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.GLOBAL.ToString(), 0x1001, tok));
                                            return;
                                        }
                                        break;
                                    default:
                                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected LOCAL or GLOBAL.", 0x0002, tok));
                                        break;
                                } // Choice Rule
                            }
                            break;
                        case TokenType.LOCAL:
                        case TokenType.GLOBAL:
                            tok = scanner.LookAhead(TokenType.LOCAL, TokenType.GLOBAL); // Choice Rule
                            switch (tok.Type)
                            { // Choice Rule
                                case TokenType.LOCAL:
                                    tok = scanner.Scan(TokenType.LOCAL); // Terminal Rule: LOCAL
                                    n = node.CreateNode(tok, tok.ToString() );
                                    node.Token.UpdateRange(tok);
                                    node.Nodes.Add(n);
                                    if (tok.Type != TokenType.LOCAL) {
                                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LOCAL.ToString(), 0x1001, tok));
                                        return;
                                    }
                                    break;
                                case TokenType.GLOBAL:
                                    tok = scanner.Scan(TokenType.GLOBAL); // Terminal Rule: GLOBAL
                                    n = node.CreateNode(tok, tok.ToString() );
                                    node.Token.UpdateRange(tok);
                                    node.Nodes.Add(n);
                                    if (tok.Type != TokenType.GLOBAL) {
                                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.GLOBAL.ToString(), 0x1001, tok));
                                        return;
                                    }
                                    break;
                                default:
                                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected LOCAL or GLOBAL.", 0x0002, tok));
                                    break;
                            } // Choice Rule
                            break;
                        default:
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected DECLARE, LOCAL, or GLOBAL.", 0x0002, tok));
                            break;
                    } // Choice Rule

                     // Concat Rule
                    tok = scanner.LookAhead(TokenType.PARAMETER, TokenType.FUNCTION, TokenType.IDENTIFIER, TokenType.LOCK); // Choice Rule
                    switch (tok.Type)
                    { // Choice Rule
                        case TokenType.PARAMETER:
                            Parsedeclare_parameter_clause(node); // NonTerminal Rule: declare_parameter_clause
                            break;
                        case TokenType.FUNCTION:
                            Parsedeclare_function_clause(node); // NonTerminal Rule: declare_function_clause
                            break;
                        case TokenType.IDENTIFIER:
                            Parsedeclare_identifier_clause(node); // NonTerminal Rule: declare_identifier_clause
                            break;
                        case TokenType.LOCK:
                            Parsedeclare_lock_clause(node); // NonTerminal Rule: declare_lock_clause
                            break;
                        default:
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected PARAMETER, FUNCTION, IDENTIFIER, or LOCK.", 0x0002, tok));
                            break;
                    } // Choice Rule
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected PARAMETER, FUNCTION, LOCK, DECLARE, LOCAL, or GLOBAL.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: declare_stmt

        private void Parsereturn_stmt(ParseNode parent) // NonTerminalSymbol: return_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.return_stmt), "return_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.RETURN); // Terminal Rule: RETURN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RETURN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RETURN.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.CHOOSE, TokenType.PLUSMINUS, TokenType.NOT, TokenType.DEFINED, TokenType.INTEGER, TokenType.DOUBLE, TokenType.TRUEFALSE, TokenType.IDENTIFIER, TokenType.FILEIDENT, TokenType.BRACKETOPEN, TokenType.STRING, TokenType.CURLYOPEN); // Option Rule
            if (tok.Type == TokenType.CHOOSE
                || tok.Type == TokenType.PLUSMINUS
                || tok.Type == TokenType.NOT
                || tok.Type == TokenType.DEFINED
                || tok.Type == TokenType.INTEGER
                || tok.Type == TokenType.DOUBLE
                || tok.Type == TokenType.TRUEFALSE
                || tok.Type == TokenType.IDENTIFIER
                || tok.Type == TokenType.FILEIDENT
                || tok.Type == TokenType.BRACKETOPEN
                || tok.Type == TokenType.STRING
                || tok.Type == TokenType.CURLYOPEN)
            {
                Parseexpr(node); // NonTerminal Rule: expr
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: return_stmt

        private void Parseswitch_stmt(ParseNode parent) // NonTerminalSymbol: switch_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.switch_stmt), "switch_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.SWITCH); // Terminal Rule: SWITCH
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SWITCH) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SWITCH.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.TO); // Terminal Rule: TO
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TO.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parseexpr(node); // NonTerminal Rule: expr

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: switch_stmt

        private void Parsecopy_stmt(ParseNode parent) // NonTerminalSymbol: copy_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.copy_stmt), "copy_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.COPY); // Terminal Rule: COPY
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.COPY) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COPY.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parseexpr(node); // NonTerminal Rule: expr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.FROM, TokenType.TO); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.FROM:
                    tok = scanner.Scan(TokenType.FROM); // Terminal Rule: FROM
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.FROM) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FROM.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.TO:
                    tok = scanner.Scan(TokenType.TO); // Terminal Rule: TO
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.TO) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TO.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected FROM or TO.", 0x0002, tok));
                    break;
            } // Choice Rule

             // Concat Rule
            Parseexpr(node); // NonTerminal Rule: expr

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: copy_stmt

        private void Parserename_stmt(ParseNode parent) // NonTerminalSymbol: rename_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.rename_stmt), "rename_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.RENAME); // Terminal Rule: RENAME
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RENAME) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RENAME.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.VOLUME, TokenType.FILE); // Option Rule
            if (tok.Type == TokenType.VOLUME
                || tok.Type == TokenType.FILE)
            {
                tok = scanner.LookAhead(TokenType.VOLUME, TokenType.FILE); // Choice Rule
                switch (tok.Type)
                { // Choice Rule
                    case TokenType.VOLUME:
                        tok = scanner.Scan(TokenType.VOLUME); // Terminal Rule: VOLUME
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.VOLUME) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.VOLUME.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    case TokenType.FILE:
                        tok = scanner.Scan(TokenType.FILE); // Terminal Rule: FILE
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.FILE) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FILE.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected VOLUME or FILE.", 0x0002, tok));
                        break;
                } // Choice Rule
            }

             // Concat Rule
            Parseexpr(node); // NonTerminal Rule: expr

             // Concat Rule
            tok = scanner.Scan(TokenType.TO); // Terminal Rule: TO
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TO.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parseexpr(node); // NonTerminal Rule: expr

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: rename_stmt

        private void Parsedelete_stmt(ParseNode parent) // NonTerminalSymbol: delete_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.delete_stmt), "delete_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.DELETE); // Terminal Rule: DELETE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.DELETE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DELETE.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parseexpr(node); // NonTerminal Rule: expr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.FROM); // Option Rule
            if (tok.Type == TokenType.FROM)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.FROM); // Terminal Rule: FROM
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.FROM) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FROM.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                Parseexpr(node); // NonTerminal Rule: expr
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: delete_stmt

        private void Parseedit_stmt(ParseNode parent) // NonTerminalSymbol: edit_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.edit_stmt), "edit_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.EDIT); // Terminal Rule: EDIT
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EDIT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EDIT.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parseexpr(node); // NonTerminal Rule: expr

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: edit_stmt

        private void Parserun_stmt(ParseNode parent) // NonTerminalSymbol: run_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.run_stmt), "run_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.RUN); // Terminal Rule: RUN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RUN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RUN.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.ONCE); // Option Rule
            if (tok.Type == TokenType.ONCE)
            {
                tok = scanner.Scan(TokenType.ONCE); // Terminal Rule: ONCE
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.ONCE) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ONCE.ToString(), 0x1001, tok));
                    return;
                }
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.FILEIDENT, TokenType.STRING); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.FILEIDENT:
                    tok = scanner.Scan(TokenType.FILEIDENT); // Terminal Rule: FILEIDENT
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.FILEIDENT) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FILEIDENT.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.STRING:
                    tok = scanner.Scan(TokenType.STRING); // Terminal Rule: STRING
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.STRING) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected FILEIDENT or STRING.", 0x0002, tok));
                    break;
            } // Choice Rule

             // Concat Rule
            tok = scanner.LookAhead(TokenType.BRACKETOPEN); // Option Rule
            if (tok.Type == TokenType.BRACKETOPEN)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.BRACKETOPEN); // Terminal Rule: BRACKETOPEN
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.BRACKETOPEN) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                Parsearglist(node); // NonTerminal Rule: arglist

                 // Concat Rule
                tok = scanner.Scan(TokenType.BRACKETCLOSE); // Terminal Rule: BRACKETCLOSE
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.BRACKETCLOSE) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString(), 0x1001, tok));
                    return;
                }
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.ON); // Option Rule
            if (tok.Type == TokenType.ON)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.ON); // Terminal Rule: ON
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.ON) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ON.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                Parseexpr(node); // NonTerminal Rule: expr
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: run_stmt

        private void Parserunpath_stmt(ParseNode parent) // NonTerminalSymbol: runpath_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.runpath_stmt), "runpath_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.RUNPATH); // Terminal Rule: RUNPATH
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RUNPATH) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RUNPATH.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.BRACKETOPEN); // Terminal Rule: BRACKETOPEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BRACKETOPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parseexpr(node); // NonTerminal Rule: expr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.COMMA); // Option Rule
            if (tok.Type == TokenType.COMMA)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.COMMA); // Terminal Rule: COMMA
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                Parsearglist(node); // NonTerminal Rule: arglist
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.BRACKETCLOSE); // Terminal Rule: BRACKETCLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BRACKETCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: runpath_stmt

        private void Parserunoncepath_stmt(ParseNode parent) // NonTerminalSymbol: runoncepath_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.runoncepath_stmt), "runoncepath_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.RUNONCEPATH); // Terminal Rule: RUNONCEPATH
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RUNONCEPATH) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RUNONCEPATH.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.BRACKETOPEN); // Terminal Rule: BRACKETOPEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BRACKETOPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parseexpr(node); // NonTerminal Rule: expr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.COMMA); // Option Rule
            if (tok.Type == TokenType.COMMA)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.COMMA); // Terminal Rule: COMMA
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                Parsearglist(node); // NonTerminal Rule: arglist
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.BRACKETCLOSE); // Terminal Rule: BRACKETCLOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BRACKETCLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: runoncepath_stmt

        private void Parsecompile_stmt(ParseNode parent) // NonTerminalSymbol: compile_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.compile_stmt), "compile_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.COMPILE); // Terminal Rule: COMPILE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.COMPILE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMPILE.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parseexpr(node); // NonTerminal Rule: expr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.TO); // Option Rule
            if (tok.Type == TokenType.TO)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.TO); // Terminal Rule: TO
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.TO) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TO.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                Parseexpr(node); // NonTerminal Rule: expr
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: compile_stmt

        private void Parselist_stmt(ParseNode parent) // NonTerminalSymbol: list_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.list_stmt), "list_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.LIST); // Terminal Rule: LIST
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LIST) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LIST.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.IDENTIFIER); // Option Rule
            if (tok.Type == TokenType.IDENTIFIER)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.IDENTIFIER) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                tok = scanner.LookAhead(TokenType.IN); // Option Rule
                if (tok.Type == TokenType.IN)
                {

                     // Concat Rule
                    tok = scanner.Scan(TokenType.IN); // Terminal Rule: IN
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IN) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IN.ToString(), 0x1001, tok));
                        return;
                    }

                     // Concat Rule
                    tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IDENTIFIER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                        return;
                    }
                }
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: list_stmt

        private void Parsereboot_stmt(ParseNode parent) // NonTerminalSymbol: reboot_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.reboot_stmt), "reboot_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.REBOOT); // Terminal Rule: REBOOT
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.REBOOT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.REBOOT.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: reboot_stmt

        private void Parseshutdown_stmt(ParseNode parent) // NonTerminalSymbol: shutdown_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.shutdown_stmt), "shutdown_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.SHUTDOWN); // Terminal Rule: SHUTDOWN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SHUTDOWN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SHUTDOWN.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: shutdown_stmt

        private void Parsefor_stmt(ParseNode parent) // NonTerminalSymbol: for_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.for_stmt), "for_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.FOR); // Terminal Rule: FOR
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.FOR) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOR.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.IN); // Terminal Rule: IN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IN.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parsevaridentifier(node); // NonTerminal Rule: varidentifier

             // Concat Rule
            Parseinstruction(node); // NonTerminal Rule: instruction

             // Concat Rule
            tok = scanner.LookAhead(TokenType.EOI); // Option Rule
            if (tok.Type == TokenType.EOI)
            {
                tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.EOI) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: for_stmt

        private void Parseunset_stmt(ParseNode parent) // NonTerminalSymbol: unset_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.unset_stmt), "unset_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.UNSET); // Terminal Rule: UNSET
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.UNSET) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.UNSET.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.IDENTIFIER, TokenType.ALL); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.IDENTIFIER:
                    tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IDENTIFIER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.ALL:
                    tok = scanner.Scan(TokenType.ALL); // Terminal Rule: ALL
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.ALL) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ALL.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected IDENTIFIER or ALL.", 0x0002, tok));
                    break;
            } // Choice Rule

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: unset_stmt

        private void Parsearglist(ParseNode parent) // NonTerminalSymbol: arglist
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.arglist), "arglist");
            parent.Nodes.Add(node);


             // Concat Rule
            Parseexpr(node); // NonTerminal Rule: expr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
            while (tok.Type == TokenType.COMMA)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.COMMA); // Terminal Rule: COMMA
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                Parseexpr(node); // NonTerminal Rule: expr
            tok = scanner.LookAhead(TokenType.COMMA); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: arglist

        private void Parseexpr(ParseNode parent) // NonTerminalSymbol: expr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.expr), "expr");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.CHOOSE, TokenType.PLUSMINUS, TokenType.NOT, TokenType.DEFINED, TokenType.INTEGER, TokenType.DOUBLE, TokenType.TRUEFALSE, TokenType.IDENTIFIER, TokenType.FILEIDENT, TokenType.BRACKETOPEN, TokenType.STRING, TokenType.CURLYOPEN); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.CHOOSE:
                    Parseternary_expr(node); // NonTerminal Rule: ternary_expr
                    break;
                case TokenType.PLUSMINUS:
                case TokenType.NOT:
                case TokenType.DEFINED:
                case TokenType.INTEGER:
                case TokenType.DOUBLE:
                case TokenType.TRUEFALSE:
                case TokenType.IDENTIFIER:
                case TokenType.FILEIDENT:
                case TokenType.BRACKETOPEN:
                case TokenType.STRING:
                    Parseor_expr(node); // NonTerminal Rule: or_expr
                    break;
                case TokenType.CURLYOPEN:
                    Parseinstruction_block(node); // NonTerminal Rule: instruction_block
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected CHOOSE, PLUSMINUS, NOT, DEFINED, INTEGER, DOUBLE, TRUEFALSE, IDENTIFIER, FILEIDENT, BRACKETOPEN, STRING, or CURLYOPEN.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: expr

        private void Parseternary_expr(ParseNode parent) // NonTerminalSymbol: ternary_expr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ternary_expr), "ternary_expr");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.CHOOSE); // Terminal Rule: CHOOSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CHOOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CHOOSE.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parseexpr(node); // NonTerminal Rule: expr

             // Concat Rule
            tok = scanner.Scan(TokenType.IF); // Terminal Rule: IF
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IF) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IF.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parseexpr(node); // NonTerminal Rule: expr

             // Concat Rule
            tok = scanner.Scan(TokenType.ELSE); // Terminal Rule: ELSE
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ELSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ELSE.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parseexpr(node); // NonTerminal Rule: expr

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ternary_expr

        private void Parseor_expr(ParseNode parent) // NonTerminalSymbol: or_expr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.or_expr), "or_expr");
            parent.Nodes.Add(node);


             // Concat Rule
            Parseand_expr(node); // NonTerminal Rule: and_expr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.OR); // ZeroOrMore Rule
            while (tok.Type == TokenType.OR)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.OR); // Terminal Rule: OR
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.OR) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OR.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                Parseand_expr(node); // NonTerminal Rule: and_expr
            tok = scanner.LookAhead(TokenType.OR); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: or_expr

        private void Parseand_expr(ParseNode parent) // NonTerminalSymbol: and_expr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.and_expr), "and_expr");
            parent.Nodes.Add(node);


             // Concat Rule
            Parsecompare_expr(node); // NonTerminal Rule: compare_expr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.AND); // ZeroOrMore Rule
            while (tok.Type == TokenType.AND)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.AND); // Terminal Rule: AND
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.AND) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.AND.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                Parsecompare_expr(node); // NonTerminal Rule: compare_expr
            tok = scanner.LookAhead(TokenType.AND); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: and_expr

        private void Parsecompare_expr(ParseNode parent) // NonTerminalSymbol: compare_expr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.compare_expr), "compare_expr");
            parent.Nodes.Add(node);


             // Concat Rule
            Parsearith_expr(node); // NonTerminal Rule: arith_expr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.COMPARATOR); // ZeroOrMore Rule
            while (tok.Type == TokenType.COMPARATOR)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.COMPARATOR); // Terminal Rule: COMPARATOR
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMPARATOR) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMPARATOR.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                Parsearith_expr(node); // NonTerminal Rule: arith_expr
            tok = scanner.LookAhead(TokenType.COMPARATOR); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: compare_expr

        private void Parsearith_expr(ParseNode parent) // NonTerminalSymbol: arith_expr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.arith_expr), "arith_expr");
            parent.Nodes.Add(node);


             // Concat Rule
            Parsemultdiv_expr(node); // NonTerminal Rule: multdiv_expr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.PLUSMINUS); // ZeroOrMore Rule
            while (tok.Type == TokenType.PLUSMINUS)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.PLUSMINUS); // Terminal Rule: PLUSMINUS
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.PLUSMINUS) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PLUSMINUS.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                Parsemultdiv_expr(node); // NonTerminal Rule: multdiv_expr
            tok = scanner.LookAhead(TokenType.PLUSMINUS); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: arith_expr

        private void Parsemultdiv_expr(ParseNode parent) // NonTerminalSymbol: multdiv_expr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.multdiv_expr), "multdiv_expr");
            parent.Nodes.Add(node);


             // Concat Rule
            Parseunary_expr(node); // NonTerminal Rule: unary_expr

             // Concat Rule
            tok = scanner.LookAhead(TokenType.MULT, TokenType.DIV); // ZeroOrMore Rule
            while (tok.Type == TokenType.MULT
                || tok.Type == TokenType.DIV)
            {

                 // Concat Rule
                tok = scanner.LookAhead(TokenType.MULT, TokenType.DIV); // Choice Rule
                switch (tok.Type)
                { // Choice Rule
                    case TokenType.MULT:
                        tok = scanner.Scan(TokenType.MULT); // Terminal Rule: MULT
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.MULT) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MULT.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    case TokenType.DIV:
                        tok = scanner.Scan(TokenType.DIV); // Terminal Rule: DIV
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.DIV) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DIV.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected MULT or DIV.", 0x0002, tok));
                        break;
                } // Choice Rule

                 // Concat Rule
                Parseunary_expr(node); // NonTerminal Rule: unary_expr
            tok = scanner.LookAhead(TokenType.MULT, TokenType.DIV); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: multdiv_expr

        private void Parseunary_expr(ParseNode parent) // NonTerminalSymbol: unary_expr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.unary_expr), "unary_expr");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.LookAhead(TokenType.PLUSMINUS, TokenType.NOT, TokenType.DEFINED); // Option Rule
            if (tok.Type == TokenType.PLUSMINUS
                || tok.Type == TokenType.NOT
                || tok.Type == TokenType.DEFINED)
            {
                tok = scanner.LookAhead(TokenType.PLUSMINUS, TokenType.NOT, TokenType.DEFINED); // Choice Rule
                switch (tok.Type)
                { // Choice Rule
                    case TokenType.PLUSMINUS:
                        tok = scanner.Scan(TokenType.PLUSMINUS); // Terminal Rule: PLUSMINUS
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.PLUSMINUS) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PLUSMINUS.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    case TokenType.NOT:
                        tok = scanner.Scan(TokenType.NOT); // Terminal Rule: NOT
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.NOT) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NOT.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    case TokenType.DEFINED:
                        tok = scanner.Scan(TokenType.DEFINED); // Terminal Rule: DEFINED
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.DEFINED) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DEFINED.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected PLUSMINUS, NOT, or DEFINED.", 0x0002, tok));
                        break;
                } // Choice Rule
            }

             // Concat Rule
            Parsefactor(node); // NonTerminal Rule: factor

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: unary_expr

        private void Parsefactor(ParseNode parent) // NonTerminalSymbol: factor
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.factor), "factor");
            parent.Nodes.Add(node);


             // Concat Rule
            Parsesuffix(node); // NonTerminal Rule: suffix

             // Concat Rule
            tok = scanner.LookAhead(TokenType.POWER); // ZeroOrMore Rule
            while (tok.Type == TokenType.POWER)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.POWER); // Terminal Rule: POWER
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.POWER) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.POWER.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                Parsesuffix(node); // NonTerminal Rule: suffix
            tok = scanner.LookAhead(TokenType.POWER); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: factor

        private void Parsesuffix(ParseNode parent) // NonTerminalSymbol: suffix
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.suffix), "suffix");
            parent.Nodes.Add(node);


             // Concat Rule
            Parsesuffixterm(node); // NonTerminal Rule: suffixterm

             // Concat Rule
            tok = scanner.LookAhead(TokenType.COLON); // ZeroOrMore Rule
            while (tok.Type == TokenType.COLON)
            {
                Parsesuffix_trailer(node); // NonTerminal Rule: suffix_trailer
            tok = scanner.LookAhead(TokenType.COLON); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: suffix

        private void Parsesuffix_trailer(ParseNode parent) // NonTerminalSymbol: suffix_trailer
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.suffix_trailer), "suffix_trailer");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.COLON); // Terminal Rule: COLON
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.COLON) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLON.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            Parsesuffixterm(node); // NonTerminal Rule: suffixterm

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: suffix_trailer

        private void Parsesuffixterm(ParseNode parent) // NonTerminalSymbol: suffixterm
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.suffixterm), "suffixterm");
            parent.Nodes.Add(node);


             // Concat Rule
            Parseatom(node); // NonTerminal Rule: atom

             // Concat Rule
            tok = scanner.LookAhead(TokenType.BRACKETOPEN, TokenType.ATSIGN, TokenType.ARRAYINDEX, TokenType.SQUAREOPEN); // ZeroOrMore Rule
            while (tok.Type == TokenType.BRACKETOPEN
                || tok.Type == TokenType.ATSIGN
                || tok.Type == TokenType.ARRAYINDEX
                || tok.Type == TokenType.SQUAREOPEN)
            {
                Parsesuffixterm_trailer(node); // NonTerminal Rule: suffixterm_trailer
            tok = scanner.LookAhead(TokenType.BRACKETOPEN, TokenType.ATSIGN, TokenType.ARRAYINDEX, TokenType.SQUAREOPEN); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: suffixterm

        private void Parsesuffixterm_trailer(ParseNode parent) // NonTerminalSymbol: suffixterm_trailer
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.suffixterm_trailer), "suffixterm_trailer");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.BRACKETOPEN, TokenType.ATSIGN, TokenType.ARRAYINDEX, TokenType.SQUAREOPEN); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.BRACKETOPEN:
                case TokenType.ATSIGN:
                    Parsefunction_trailer(node); // NonTerminal Rule: function_trailer
                    break;
                case TokenType.ARRAYINDEX:
                case TokenType.SQUAREOPEN:
                    Parsearray_trailer(node); // NonTerminal Rule: array_trailer
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected BRACKETOPEN, ATSIGN, ARRAYINDEX, or SQUAREOPEN.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: suffixterm_trailer

        private void Parsefunction_trailer(ParseNode parent) // NonTerminalSymbol: function_trailer
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.function_trailer), "function_trailer");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.BRACKETOPEN, TokenType.ATSIGN); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.BRACKETOPEN:

                     // Concat Rule
                    tok = scanner.Scan(TokenType.BRACKETOPEN); // Terminal Rule: BRACKETOPEN
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.BRACKETOPEN) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString(), 0x1001, tok));
                        return;
                    }

                     // Concat Rule
                    tok = scanner.LookAhead(TokenType.CHOOSE, TokenType.PLUSMINUS, TokenType.NOT, TokenType.DEFINED, TokenType.INTEGER, TokenType.DOUBLE, TokenType.TRUEFALSE, TokenType.IDENTIFIER, TokenType.FILEIDENT, TokenType.BRACKETOPEN, TokenType.STRING, TokenType.CURLYOPEN); // Option Rule
                    if (tok.Type == TokenType.CHOOSE
                        || tok.Type == TokenType.PLUSMINUS
                        || tok.Type == TokenType.NOT
                        || tok.Type == TokenType.DEFINED
                        || tok.Type == TokenType.INTEGER
                        || tok.Type == TokenType.DOUBLE
                        || tok.Type == TokenType.TRUEFALSE
                        || tok.Type == TokenType.IDENTIFIER
                        || tok.Type == TokenType.FILEIDENT
                        || tok.Type == TokenType.BRACKETOPEN
                        || tok.Type == TokenType.STRING
                        || tok.Type == TokenType.CURLYOPEN)
                    {
                        Parsearglist(node); // NonTerminal Rule: arglist
                    }

                     // Concat Rule
                    tok = scanner.Scan(TokenType.BRACKETCLOSE); // Terminal Rule: BRACKETCLOSE
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.BRACKETCLOSE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.ATSIGN:
                    tok = scanner.Scan(TokenType.ATSIGN); // Terminal Rule: ATSIGN
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.ATSIGN) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ATSIGN.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected BRACKETOPEN or ATSIGN.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: function_trailer

        private void Parsearray_trailer(ParseNode parent) // NonTerminalSymbol: array_trailer
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.array_trailer), "array_trailer");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.ARRAYINDEX, TokenType.SQUAREOPEN); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.ARRAYINDEX:

                     // Concat Rule
                    tok = scanner.Scan(TokenType.ARRAYINDEX); // Terminal Rule: ARRAYINDEX
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.ARRAYINDEX) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ARRAYINDEX.ToString(), 0x1001, tok));
                        return;
                    }

                     // Concat Rule
                    tok = scanner.LookAhead(TokenType.IDENTIFIER, TokenType.INTEGER); // Choice Rule
                    switch (tok.Type)
                    { // Choice Rule
                        case TokenType.IDENTIFIER:
                            tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.IDENTIFIER) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                                return;
                            }
                            break;
                        case TokenType.INTEGER:
                            tok = scanner.Scan(TokenType.INTEGER); // Terminal Rule: INTEGER
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.INTEGER) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INTEGER.ToString(), 0x1001, tok));
                                return;
                            }
                            break;
                        default:
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected IDENTIFIER or INTEGER.", 0x0002, tok));
                            break;
                    } // Choice Rule
                    break;
                case TokenType.SQUAREOPEN:

                     // Concat Rule
                    tok = scanner.Scan(TokenType.SQUAREOPEN); // Terminal Rule: SQUAREOPEN
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.SQUAREOPEN) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SQUAREOPEN.ToString(), 0x1001, tok));
                        return;
                    }

                     // Concat Rule
                    Parseexpr(node); // NonTerminal Rule: expr

                     // Concat Rule
                    tok = scanner.Scan(TokenType.SQUARECLOSE); // Terminal Rule: SQUARECLOSE
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.SQUARECLOSE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SQUARECLOSE.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected ARRAYINDEX or SQUAREOPEN.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: array_trailer

        private void Parseatom(ParseNode parent) // NonTerminalSymbol: atom
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.atom), "atom");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.INTEGER, TokenType.DOUBLE, TokenType.TRUEFALSE, TokenType.IDENTIFIER, TokenType.FILEIDENT, TokenType.BRACKETOPEN, TokenType.STRING); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.INTEGER:
                case TokenType.DOUBLE:
                case TokenType.TRUEFALSE:
                case TokenType.IDENTIFIER:
                case TokenType.FILEIDENT:
                case TokenType.BRACKETOPEN:
                    tok = scanner.LookAhead(TokenType.INTEGER, TokenType.DOUBLE, TokenType.TRUEFALSE, TokenType.IDENTIFIER, TokenType.FILEIDENT, TokenType.BRACKETOPEN); // Choice Rule
                    switch (tok.Type)
                    { // Choice Rule
                        case TokenType.INTEGER:
                        case TokenType.DOUBLE:
                            Parsesci_number(node); // NonTerminal Rule: sci_number
                            break;
                        case TokenType.TRUEFALSE:
                            tok = scanner.Scan(TokenType.TRUEFALSE); // Terminal Rule: TRUEFALSE
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.TRUEFALSE) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TRUEFALSE.ToString(), 0x1001, tok));
                                return;
                            }
                            break;
                        case TokenType.IDENTIFIER:
                            tok = scanner.Scan(TokenType.IDENTIFIER); // Terminal Rule: IDENTIFIER
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.IDENTIFIER) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                                return;
                            }
                            break;
                        case TokenType.FILEIDENT:
                            tok = scanner.Scan(TokenType.FILEIDENT); // Terminal Rule: FILEIDENT
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.FILEIDENT) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FILEIDENT.ToString(), 0x1001, tok));
                                return;
                            }
                            break;
                        case TokenType.BRACKETOPEN:

                             // Concat Rule
                            tok = scanner.Scan(TokenType.BRACKETOPEN); // Terminal Rule: BRACKETOPEN
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.BRACKETOPEN) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString(), 0x1001, tok));
                                return;
                            }

                             // Concat Rule
                            Parseexpr(node); // NonTerminal Rule: expr

                             // Concat Rule
                            tok = scanner.Scan(TokenType.BRACKETCLOSE); // Terminal Rule: BRACKETCLOSE
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.BRACKETCLOSE) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString(), 0x1001, tok));
                                return;
                            }
                            break;
                        default:
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected INTEGER, DOUBLE, TRUEFALSE, IDENTIFIER, FILEIDENT, or BRACKETOPEN.", 0x0002, tok));
                            break;
                    } // Choice Rule
                    break;
                case TokenType.STRING:
                    tok = scanner.Scan(TokenType.STRING); // Terminal Rule: STRING
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.STRING) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected INTEGER, DOUBLE, TRUEFALSE, IDENTIFIER, FILEIDENT, BRACKETOPEN, or STRING.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: atom

        private void Parsesci_number(ParseNode parent) // NonTerminalSymbol: sci_number
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.sci_number), "sci_number");
            parent.Nodes.Add(node);


             // Concat Rule
            Parsenumber(node); // NonTerminal Rule: number

             // Concat Rule
            tok = scanner.LookAhead(TokenType.E); // Option Rule
            if (tok.Type == TokenType.E)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.E); // Terminal Rule: E
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.E) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.E.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                tok = scanner.LookAhead(TokenType.PLUSMINUS); // Option Rule
                if (tok.Type == TokenType.PLUSMINUS)
                {
                    tok = scanner.Scan(TokenType.PLUSMINUS); // Terminal Rule: PLUSMINUS
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.PLUSMINUS) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PLUSMINUS.ToString(), 0x1001, tok));
                        return;
                    }
                }

                 // Concat Rule
                tok = scanner.Scan(TokenType.INTEGER); // Terminal Rule: INTEGER
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.INTEGER) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INTEGER.ToString(), 0x1001, tok));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: sci_number

        private void Parsenumber(ParseNode parent) // NonTerminalSymbol: number
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.number), "number");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.INTEGER, TokenType.DOUBLE); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.INTEGER:
                    tok = scanner.Scan(TokenType.INTEGER); // Terminal Rule: INTEGER
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.INTEGER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INTEGER.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.DOUBLE:
                    tok = scanner.Scan(TokenType.DOUBLE); // Terminal Rule: DOUBLE
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.DOUBLE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOUBLE.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected INTEGER or DOUBLE.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: number

        private void Parsevaridentifier(ParseNode parent) // NonTerminalSymbol: varidentifier
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.varidentifier), "varidentifier");
            parent.Nodes.Add(node);

            Parsesuffix(node); // NonTerminal Rule: suffix

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: varidentifier

        private void Parseidentifier_led_stmt(ParseNode parent) // NonTerminalSymbol: identifier_led_stmt
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.identifier_led_stmt), "identifier_led_stmt");
            parent.Nodes.Add(node);


             // Concat Rule
            Parseidentifier_led_expr(node); // NonTerminal Rule: identifier_led_expr

             // Concat Rule
            tok = scanner.Scan(TokenType.EOI); // Terminal Rule: EOI
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: identifier_led_stmt

        private void Parseidentifier_led_expr(ParseNode parent) // NonTerminalSymbol: identifier_led_expr
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.identifier_led_expr), "identifier_led_expr");
            parent.Nodes.Add(node);


             // Concat Rule
            Parsesuffix(node); // NonTerminal Rule: suffix

             // Concat Rule
            tok = scanner.LookAhead(TokenType.ON, TokenType.OFF); // Option Rule
            if (tok.Type == TokenType.ON
                || tok.Type == TokenType.OFF)
            {
                Parseonoff_trailer(node); // NonTerminal Rule: onoff_trailer
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: identifier_led_expr


    }

    #endregion Parser
}
