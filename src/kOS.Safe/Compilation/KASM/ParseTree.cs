// Generated by TinyPG v1.3 available at www.codeproject.com

using kOS.Safe.Encapsulation;
using kOS.Safe.Execution;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using System.Xml.Serialization;

namespace kOS.Safe.Compilation.KASM
{
    #region ParseTree
    [Serializable]
    public class ParseErrors : List<ParseError>
    {
    }

    [Serializable]
    public class ParseError
    {
        private string message;
        private int code;
        private int line;
        private int col;
        private int pos;
        private int length;

        public int Code { get { return code; } }
        public int Line { get { return line; } }
        public int Column { get { return col; } }
        public int Position { get { return pos; } }
        public int Length { get { return length; } }
        public string Message { get { return message; } }

        // just for the sake of serialization
        public ParseError()
        {
        }

        public ParseError(string message, int code, ParseNode node) : this(message, code,  0, node.Token.StartPos, node.Token.StartPos, node.Token.Length)
        {
        }

        public ParseError(string message, int code, int line, int col, int pos, int length)
        {
            this.message = message;
            this.code = code;
            this.line = line;
            this.col = col;
            this.pos = pos;
            this.length = length;
        }
    }

    // rootlevel of the node tree
    [Serializable]
    public partial class ParseTree : ParseNode
    {
        public ParseErrors Errors;

        public List<Token> Skipped;

        public ParseTree() : base(new Token(), "ParseTree")
        {
            Token.Type = TokenType.Start;
            Token.Text = "Root";
            Errors = new ParseErrors();
        }

        public string PrintTree()
        {
            StringBuilder sb = new StringBuilder();
            int indent = 0;
            PrintNode(sb, this, indent);
            return sb.ToString();
        }

        private void PrintNode(StringBuilder sb, ParseNode node, int indent)
        {
            
            string space = "".PadLeft(indent, ' ');

            sb.Append(space);
            sb.AppendLine(node.Text);

            foreach (ParseNode n in node.Nodes)
                PrintNode(sb, n, indent + 2);
        }
        
        /// <summary>
        /// this is the entry point for executing and evaluating the parse tree.
        /// </summary>
        /// <param name="paramlist">additional optional input parameters</param>
        /// <returns>the output of the evaluation function</returns>
        public object Eval(params object[] paramlist)
        {
            return Nodes[0].Eval(this, paramlist);
        }
    }

    [Serializable]
    [XmlInclude(typeof(ParseTree))]
    public partial class ParseNode
    {
        protected string text;
        protected List<ParseNode> nodes;
        
        public List<ParseNode> Nodes { get {return nodes;} }
        
        [XmlIgnore] // avoid circular references when serializing
        public ParseNode Parent;
        public Token Token; // the token/rule

        [XmlIgnore] // skip redundant text (is part of Token)
        public string Text { // text to display in parse tree 
            get { return text;} 
            set { text = value; }
        } 

        public virtual ParseNode CreateNode(Token token, string text)
        {
            ParseNode node = new ParseNode(token, text);
            node.Parent = this;
            return node;
        }

        protected ParseNode(Token token, string text)
        {
            this.Token = token;
            this.text = text;
            this.nodes = new List<ParseNode>();
        }

        protected object GetValue(ParseTree tree, TokenType type, int index)
        {
            return GetValue(tree, type, ref index);
        }

        protected object GetValue(ParseTree tree, TokenType type, ref int index)
        {
            object o = null;
            if (index < 0) return o;

            // left to right
            foreach (ParseNode node in nodes)
            {
                if (node.Token.Type == type)
                {
                    index--;
                    if (index < 0)
                    {
                        o = node.Eval(tree);
                        break;
                    }
                }
            }
            return o;
        }

        /// <summary>
        /// this implements the evaluation functionality, cannot be used directly
        /// </summary>
        /// <param name="tree">the parsetree itself</param>
        /// <param name="paramlist">optional input parameters</param>
        /// <returns>a partial result of the evaluation</returns>
        internal object Eval(ParseTree tree, params object[] paramlist)
        {
            object Value = null;

            switch (Token.Type)
            {
                case TokenType.DecodedUnicode:
                    Value = EvalDecodedUnicode(tree, paramlist);
                    break;
                case TokenType.StringChar:
                    Value = EvalStringChar(tree, paramlist);
                    break;
                case TokenType.ParsedString:
                    Value = EvalParsedString(tree, paramlist);
                    break;
                case TokenType.ParsedInt:
                    Value = EvalParsedInt(tree, paramlist);
                    break;
                case TokenType.ParsedBoolean:
                    Value = EvalParsedBoolean(tree, paramlist);
                    break;
                case TokenType.ParsedDouble:
                    Value = EvalParsedDouble(tree, paramlist);
                    break;
                case TokenType.WrappedValue:
                    Value = EvalWrappedValue(tree, paramlist);
                    break;
                case TokenType.Argument:
                    Value = EvalArgument(tree, paramlist);
                    break;
                case TokenType.SecondArgument:
                    Value = EvalSecondArgument(tree, paramlist);
                    break;
                case TokenType.ArgumentList:
                    Value = EvalArgumentList(tree, paramlist);
                    break;
                case TokenType.Instruction:
                    Value = EvalInstruction(tree, paramlist);
                    break;
                case TokenType.Line:
                    Value = EvalLine(tree, paramlist);
                    break;
                case TokenType.CodeBlock:
                    Value = EvalCodeBlock(tree, paramlist);
                    break;
                case TokenType.FunctionSection:
                    Value = EvalFunctionSection(tree, paramlist);
                    break;
                case TokenType.InitSection:
                    Value = EvalInitSection(tree, paramlist);
                    break;
                case TokenType.MainSection:
                    Value = EvalMainSection(tree, paramlist);
                    break;
                case TokenType.CodePart:
                    Value = EvalCodePart(tree, paramlist);
                    break;
                case TokenType.Start:
                    Value = EvalStart(tree, paramlist);
                    break;

                default:
                    Value = Token.Text;
                    break;
            }
            return Value;
        }

        protected virtual object EvalDecodedUnicode(ParseTree tree, params object[] paramlist)
        {
            string original = (string)this.GetValue(tree, TokenType.UNICODE_CHAR, 0);
        	string hexpart = original.Substring(2);
        	char c = (char)int.Parse(hexpart, NumberStyles.HexNumber);
        	return "" + c;
        }

        protected virtual object EvalStringChar(ParseTree tree, params object[] paramlist)
        {
            if ( this.GetValue(tree, TokenType.OTHER_CHAR, 0) != null ) return this.GetValue(tree, TokenType.OTHER_CHAR, 0);
        	if ( this.GetValue(tree, TokenType.ENCODED_NEWLINE, 0) != null ) return "\n";
        	if ( this.GetValue(tree, TokenType.ENCODED_TAB, 0) != null ) return "\t";
        	if ( this.GetValue(tree, TokenType.ENCODED_QUOTE, 0) != null ) return "\"";
        	if ( this.GetValue(tree, TokenType.ENCODED_BACKSLASH, 0) != null ) return "\\";
        	if ( this.GetValue(tree, TokenType.DecodedUnicode, 0) != null ) return this.GetValue(tree, TokenType.DecodedUnicode, 0);
        	return "";
        }

        protected virtual object EvalParsedString(ParseTree tree, params object[] paramlist)
        {
            StringBuilder b = new StringBuilder();
        	int i = 0;
        
        	while(this.GetValue(tree, TokenType.StringChar, i) != null) {
        		b.Append(this.GetValue(tree, TokenType.StringChar, i++));
        	}
        
        	return b.ToString();
        }

        protected virtual object EvalParsedInt(ParseTree tree, params object[] paramlist)
        {
            return Int32.Parse(this.GetValue(tree, TokenType.INT, 0).ToString().Substring(0, this.GetValue(tree, TokenType.INT, 0).ToString().Length - 1));
        }

        protected virtual object EvalParsedBoolean(ParseTree tree, params object[] paramlist)
        {
            return bool.Parse(this.GetValue(tree, TokenType.BOOLEAN, 0).ToString());
        }

        protected virtual object EvalParsedDouble(ParseTree tree, params object[] paramlist)
        {
            return double.Parse(this.GetValue(tree, TokenType.DOUBLE, 0).ToString().Substring(0, this.GetValue(tree, TokenType.DOUBLE, 0).ToString().Length - 1), CultureInfo.InvariantCulture);
        }

        protected virtual object EvalWrappedValue(ParseTree tree, params object[] paramlist)
        {
            if ( this.GetValue(tree, TokenType.ParsedInt, 0) != null ) return new ScalarIntValue( (int)this.GetValue(tree, TokenType.ParsedInt, 0) );
        	if ( this.GetValue(tree, TokenType.ParsedDouble, 0) != null ) return new ScalarDoubleValue( (double)this.GetValue(tree, TokenType.ParsedDouble, 0) );
        	if ( this.GetValue(tree, TokenType.ParsedBoolean, 0) != null ) return new BooleanValue( (bool)this.GetValue(tree, TokenType.ParsedBoolean, 0) );
        	if ( this.GetValue(tree, TokenType.ParsedString, 0)!= null ) return new StringValue( (string)this.GetValue(tree, TokenType.ParsedString, 0));
        	return null;
        }

        protected virtual object EvalArgument(ParseTree tree, params object[] paramlist)
        {
            if ( this.GetValue(tree, TokenType.PSEUDONULL, 0) != null) return null;
        	if ( this.GetValue(tree, TokenType.ParsedBoolean, 0) != null) return this.GetValue(tree, TokenType.ParsedBoolean, 0);
        	if ( this.GetValue(tree, TokenType.ParsedString, 0)!= null) return this.GetValue(tree, TokenType.ParsedString, 0);
        	if ( this.GetValue(tree, TokenType.ParsedDouble, 0) != null) return this.GetValue(tree, TokenType.ParsedDouble, 0);
        	if ( this.GetValue(tree, TokenType.SINGLE, 0) != null) return float.Parse(this.GetValue(tree, TokenType.SINGLE, 0).ToString().Substring(0, this.GetValue(tree, TokenType.SINGLE, 0).ToString().Length - 1));
        	if ( this.GetValue(tree, TokenType.BYTE, 0) != null) return byte.Parse(this.GetValue(tree, TokenType.BYTE, 0).ToString().Substring(0, this.GetValue(tree, TokenType.BYTE, 0).ToString().Length - 1));
        	if ( this.GetValue(tree, TokenType.CHAR, 0) != null) return (char)Int32.Parse(this.GetValue(tree, TokenType.CHAR, 0).ToString().Substring(0, this.GetValue(tree, TokenType.CHAR, 0).ToString().Length - 1));
        	if ( this.GetValue(tree, TokenType.DECIMAL, 0) != null) return Decimal.Parse(this.GetValue(tree, TokenType.DECIMAL, 0).ToString().Substring(0, this.GetValue(tree, TokenType.DECIMAL, 0).ToString().Length - 1), CultureInfo.InvariantCulture);
        	if ( this.GetValue(tree, TokenType.SHORT, 0) != null) return Int16.Parse(this.GetValue(tree, TokenType.SHORT, 0).ToString().Substring(0, this.GetValue(tree, TokenType.SHORT, 0).ToString().Length - 1), CultureInfo.InvariantCulture);
        	if ( this.GetValue(tree, TokenType.LONG, 0) != null) return Int64.Parse(this.GetValue(tree, TokenType.LONG, 0).ToString().Substring(0, this.GetValue(tree, TokenType.LONG, 0).ToString().Length - 1));
        	if ( this.GetValue(tree, TokenType.ParsedInt, 0) != null) return this.GetValue(tree, TokenType.ParsedInt, 0);
        	if ( this.GetValue(tree, TokenType.UNSIGNEDSHORT, 0) != null) return UInt16.Parse(this.GetValue(tree, TokenType.UNSIGNEDSHORT, 0).ToString().Substring(0, this.GetValue(tree, TokenType.UNSIGNEDSHORT, 0).ToString().Length - 1));
        	if ( this.GetValue(tree, TokenType.UNSIGNEDINT, 0) != null) return UInt32.Parse(this.GetValue(tree, TokenType.UNSIGNEDINT, 0).ToString().Substring(0, this.GetValue(tree, TokenType.UNSIGNEDINT, 0).ToString().Length - 1));
        	if ( this.GetValue(tree, TokenType.UNSIGNEDLONG, 0) != null) return UInt64.Parse(this.GetValue(tree, TokenType.UNSIGNEDLONG, 0).ToString().Substring(0, this.GetValue(tree, TokenType.UNSIGNEDLONG, 0).ToString().Length - 1));
        	if ( this.GetValue(tree, TokenType.SIGNEDBYTE, 0) != null) return sbyte.Parse(this.GetValue(tree, TokenType.SIGNEDBYTE, 0).ToString().Substring(0, this.GetValue(tree, TokenType.SIGNEDBYTE, 0).ToString().Length - 1));
        	if ( this.GetValue(tree, TokenType.WrappedValue, 0) != null) return this.GetValue(tree, TokenType.WrappedValue, 0);
        	if ( this.GetValue(tree, TokenType.MARK, 0) != null ) return new KOSArgMarkerType();
        	return null;
        }

        protected virtual object EvalSecondArgument(ParseTree tree, params object[] paramlist)
        {
            return this.GetValue(tree, TokenType.Argument, 0);
        }

        protected virtual object EvalArgumentList(ParseTree tree, params object[] paramlist)
        {
            int i = 0;
        	List<object> results = new List<object>();
        	results.Add(this.GetValue(tree, TokenType.Argument, 0));
        	while(this.GetValue(tree, TokenType.SecondArgument, i) != null) {
        		results.Add(this.GetValue(tree, TokenType.SecondArgument, i++));
        	}
        	return results;
        }

        protected virtual object EvalInstruction(ParseTree tree, params object[] paramlist)
        {
            List<object> operation = new List<object>();
        	operation.Add(this.GetValue(tree, TokenType.OPERATION, 0));
        	if(this.GetValue(tree, TokenType.ArgumentList, 0) != null)
        		operation.AddRange((List<object>)this.GetValue(tree, TokenType.ArgumentList, 0));
        
        	return operation;
        }

        protected virtual object EvalLine(ParseTree tree, params object[] paramlist)
        {
            List<object> result = new List<object>();
        	if(this.GetValue(tree, TokenType.LABEL, 0) != null) {
        		string label = this.GetValue(tree, TokenType.LABEL, 0).ToString();
        		label = label.Substring(0, label.Length - 1);
        		result.Add(label);
        	} else {
        		result.Add(null);
        	}
        	result.AddRange((List<object>)this.GetValue(tree, TokenType.Instruction, 0));
        	return result;
        }

        protected virtual object EvalCodeBlock(ParseTree tree, params object[] paramlist)
        {
            int i = 0;
        	List<List<object>> block = new List<List<object>>();
        	while(this.GetValue(tree, TokenType.Line, i) != null) {
        		block.Add((List<object>)this.GetValue(tree, TokenType.Line, i++));
        	}
        	return block;
        }

        protected virtual object EvalFunctionSection(ParseTree tree, params object[] paramlist)
        {
            return this.GetValue(tree, TokenType.CodeBlock, 0);
        }

        protected virtual object EvalInitSection(ParseTree tree, params object[] paramlist)
        {
            return this.GetValue(tree, TokenType.CodeBlock, 0);
        }

        protected virtual object EvalMainSection(ParseTree tree, params object[] paramlist)
        {
            return this.GetValue(tree, TokenType.CodeBlock, 0);
        }

        protected virtual object EvalCodePart(ParseTree tree, params object[] paramlist)
        {
            List<List<List<object>>> part = new List<List<List<object>>>();
        
        	part.Add((List<List<object>>)this.GetValue(tree, TokenType.FunctionSection, 0));
        	part.Add((List<List<object>>)this.GetValue(tree, TokenType.InitSection, 0));
        	part.Add((List<List<object>>)this.GetValue(tree, TokenType.MainSection, 0));
        
        	return part;
        }

        protected virtual object EvalStart(ParseTree tree, params object[] paramlist)
        {
            List<List<List<List<object>>>> file = new List<List<List<List<object>>>>();
        	int i = 0;
        	while(this.GetValue(tree, TokenType.CodePart, i) != null) {
        		file.Add((List<List<List<object>>>)this.GetValue(tree, TokenType.CodePart, i++));
        	}
        	return file;
        }


    }
    
    #endregion ParseTree
}
