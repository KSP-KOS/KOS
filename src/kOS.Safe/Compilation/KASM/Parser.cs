// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;

namespace kOS.Safe.Compilation.KASM
{
    #region Parser

    public partial class Parser 
    {
        private Scanner scanner;
        private ParseTree tree;
        
        public Parser(Scanner scanner)
        {
            this.scanner = scanner;
        }

        public ParseTree Parse(string input)
        {
            tree = new ParseTree();
            return Parse(input, tree);
        }

        public ParseTree Parse(string input, ParseTree tree)
        {
            scanner.Init(input);

            this.tree = tree;
            ParseStart(tree);
            tree.Skipped = scanner.Skipped;

            return tree;
        }

        private void ParseDecodedUnicode(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.DecodedUnicode), "DecodedUnicode");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.UNICODE_CHAR);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.UNICODE_CHAR) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.UNICODE_CHAR.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseStringChar(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.StringChar), "StringChar");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.OTHER_CHAR, TokenType.ENCODED_NEWLINE, TokenType.ENCODED_TAB, TokenType.ENCODED_QUOTE, TokenType.ENCODED_BACKSLASH, TokenType.UNICODE_CHAR);
            switch (tok.Type)
            {
                case TokenType.OTHER_CHAR:
                    tok = scanner.Scan(TokenType.OTHER_CHAR);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.OTHER_CHAR) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OTHER_CHAR.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.ENCODED_NEWLINE:
                    tok = scanner.Scan(TokenType.ENCODED_NEWLINE);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.ENCODED_NEWLINE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ENCODED_NEWLINE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.ENCODED_TAB:
                    tok = scanner.Scan(TokenType.ENCODED_TAB);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.ENCODED_TAB) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ENCODED_TAB.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.ENCODED_QUOTE:
                    tok = scanner.Scan(TokenType.ENCODED_QUOTE);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.ENCODED_QUOTE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ENCODED_QUOTE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.ENCODED_BACKSLASH:
                    tok = scanner.Scan(TokenType.ENCODED_BACKSLASH);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.ENCODED_BACKSLASH) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ENCODED_BACKSLASH.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.UNICODE_CHAR:
                    ParseDecodedUnicode(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseParsedString(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ParsedString), "ParsedString");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.STRING_DELIMITER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.STRING_DELIMITER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING_DELIMITER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.OTHER_CHAR, TokenType.ENCODED_NEWLINE, TokenType.ENCODED_TAB, TokenType.ENCODED_QUOTE, TokenType.ENCODED_BACKSLASH, TokenType.UNICODE_CHAR);
            while (tok.Type == TokenType.OTHER_CHAR
                || tok.Type == TokenType.ENCODED_NEWLINE
                || tok.Type == TokenType.ENCODED_TAB
                || tok.Type == TokenType.ENCODED_QUOTE
                || tok.Type == TokenType.ENCODED_BACKSLASH
                || tok.Type == TokenType.UNICODE_CHAR)
            {
                ParseStringChar(node);
            tok = scanner.LookAhead(TokenType.OTHER_CHAR, TokenType.ENCODED_NEWLINE, TokenType.ENCODED_TAB, TokenType.ENCODED_QUOTE, TokenType.ENCODED_BACKSLASH, TokenType.UNICODE_CHAR);
            }

            
            tok = scanner.Scan(TokenType.STRING_DELIMITER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.STRING_DELIMITER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING_DELIMITER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseParsedInt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ParsedInt), "ParsedInt");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.INT);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.INT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseParsedBoolean(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ParsedBoolean), "ParsedBoolean");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.BOOLEAN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BOOLEAN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BOOLEAN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseParsedDouble(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ParsedDouble), "ParsedDouble");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.DOUBLE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.DOUBLE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOUBLE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseWrappedValue(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.WrappedValue), "WrappedValue");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.WRAPPEDVALUEINDICATOR);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.WRAPPEDVALUEINDICATOR) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WRAPPEDVALUEINDICATOR.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.INT, TokenType.DOUBLE, TokenType.BOOLEAN, TokenType.STRING_DELIMITER);
            switch (tok.Type)
            {
                case TokenType.INT:
                    ParseParsedInt(node);
                    break;
                case TokenType.DOUBLE:
                    ParseParsedDouble(node);
                    break;
                case TokenType.BOOLEAN:
                    ParseParsedBoolean(node);
                    break;
                case TokenType.STRING_DELIMITER:
                    ParseParsedString(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseArgument(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Argument), "Argument");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.PSEUDONULL, TokenType.BOOLEAN, TokenType.STRING_DELIMITER, TokenType.DOUBLE, TokenType.SINGLE, TokenType.BYTE, TokenType.CHAR, TokenType.DECIMAL, TokenType.SHORT, TokenType.LONG, TokenType.INT, TokenType.UNSIGNEDSHORT, TokenType.UNSIGNEDINT, TokenType.UNSIGNEDLONG, TokenType.SIGNEDBYTE, TokenType.WRAPPEDVALUEINDICATOR, TokenType.MARK);
            switch (tok.Type)
            {
                case TokenType.PSEUDONULL:
                    tok = scanner.Scan(TokenType.PSEUDONULL);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.PSEUDONULL) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PSEUDONULL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.BOOLEAN:
                    ParseParsedBoolean(node);
                    break;
                case TokenType.STRING_DELIMITER:
                    ParseParsedString(node);
                    break;
                case TokenType.DOUBLE:
                    ParseParsedDouble(node);
                    break;
                case TokenType.SINGLE:
                    tok = scanner.Scan(TokenType.SINGLE);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.SINGLE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SINGLE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.BYTE:
                    tok = scanner.Scan(TokenType.BYTE);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.BYTE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BYTE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.CHAR:
                    tok = scanner.Scan(TokenType.CHAR);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CHAR) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CHAR.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.DECIMAL:
                    tok = scanner.Scan(TokenType.DECIMAL);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.DECIMAL) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DECIMAL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.SHORT:
                    tok = scanner.Scan(TokenType.SHORT);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.SHORT) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SHORT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.LONG:
                    tok = scanner.Scan(TokenType.LONG);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.LONG) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LONG.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.INT:
                    ParseParsedInt(node);
                    break;
                case TokenType.UNSIGNEDSHORT:
                    tok = scanner.Scan(TokenType.UNSIGNEDSHORT);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.UNSIGNEDSHORT) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.UNSIGNEDSHORT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.UNSIGNEDINT:
                    tok = scanner.Scan(TokenType.UNSIGNEDINT);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.UNSIGNEDINT) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.UNSIGNEDINT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.UNSIGNEDLONG:
                    tok = scanner.Scan(TokenType.UNSIGNEDLONG);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.UNSIGNEDLONG) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.UNSIGNEDLONG.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.SIGNEDBYTE:
                    tok = scanner.Scan(TokenType.SIGNEDBYTE);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.SIGNEDBYTE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SIGNEDBYTE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.WRAPPEDVALUEINDICATOR:
                    ParseWrappedValue(node);
                    break;
                case TokenType.MARK:
                    tok = scanner.Scan(TokenType.MARK);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.MARK) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MARK.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseSecondArgument(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.SecondArgument), "SecondArgument");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.ARGUMENTSEPARATOR);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ARGUMENTSEPARATOR) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ARGUMENTSEPARATOR.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.WHITESPACE);
            if (tok.Type == TokenType.WHITESPACE)
            {
                tok = scanner.Scan(TokenType.WHITESPACE);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.WHITESPACE) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WHITESPACE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            }

            
            ParseArgument(node);

            
            tok = scanner.LookAhead(TokenType.WHITESPACE);
            if (tok.Type == TokenType.WHITESPACE)
            {
                tok = scanner.Scan(TokenType.WHITESPACE);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.WHITESPACE) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WHITESPACE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseArgumentList(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ArgumentList), "ArgumentList");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.WHITESPACE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.WHITESPACE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WHITESPACE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParseArgument(node);

            
            tok = scanner.LookAhead(TokenType.WHITESPACE);
            if (tok.Type == TokenType.WHITESPACE)
            {
                tok = scanner.Scan(TokenType.WHITESPACE);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.WHITESPACE) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WHITESPACE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            }

            
            tok = scanner.LookAhead(TokenType.ARGUMENTSEPARATOR);
            while (tok.Type == TokenType.ARGUMENTSEPARATOR)
            {
                ParseSecondArgument(node);
            tok = scanner.LookAhead(TokenType.ARGUMENTSEPARATOR);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseInstruction(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Instruction), "Instruction");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.OPERATION);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.OPERATION) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OPERATION.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.WHITESPACE);
            if (tok.Type == TokenType.WHITESPACE)
            {
                ParseArgumentList(node);
            }

            
            tok = scanner.Scan(TokenType.ENDL);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ENDL) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ENDL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseLine(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Line), "Line");
            parent.Nodes.Add(node);


            
            tok = scanner.LookAhead(TokenType.WHITESPACE);
            if (tok.Type == TokenType.WHITESPACE)
            {
                tok = scanner.Scan(TokenType.WHITESPACE);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.WHITESPACE) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WHITESPACE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            }

            
            tok = scanner.LookAhead(TokenType.LABEL);
            if (tok.Type == TokenType.LABEL)
            {

                
                tok = scanner.Scan(TokenType.LABEL);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.LABEL) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LABEL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                tok = scanner.Scan(TokenType.WHITESPACE);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.WHITESPACE) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WHITESPACE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            }

            
            ParseInstruction(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseCodeBlock(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.CodeBlock), "CodeBlock");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.WHITESPACE, TokenType.LABEL, TokenType.OPERATION);
            while (tok.Type == TokenType.WHITESPACE
                || tok.Type == TokenType.LABEL
                || tok.Type == TokenType.OPERATION)
            {
                ParseLine(node);
            tok = scanner.LookAhead(TokenType.WHITESPACE, TokenType.LABEL, TokenType.OPERATION);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseFunctionSection(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.FunctionSection), "FunctionSection");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.FUNCTIONSECTIONMARK);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.FUNCTIONSECTIONMARK) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FUNCTIONSECTIONMARK.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.ENDL);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ENDL) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ENDL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParseCodeBlock(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseInitSection(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.InitSection), "InitSection");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.INITSECTIONMARK);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.INITSECTIONMARK) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INITSECTIONMARK.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.ENDL);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ENDL) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ENDL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParseCodeBlock(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseMainSection(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.MainSection), "MainSection");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.MAINSECTIONMARK);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.MAINSECTIONMARK) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MAINSECTIONMARK.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.ENDL);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ENDL) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ENDL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParseCodeBlock(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseCodePart(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.CodePart), "CodePart");
            parent.Nodes.Add(node);


            
            ParseFunctionSection(node);

            
            tok = scanner.LookAhead(TokenType.INITSECTIONMARK, TokenType.MAINSECTIONMARK);
            if (tok.Type == TokenType.INITSECTIONMARK
                || tok.Type == TokenType.MAINSECTIONMARK)
            {
                tok = scanner.LookAhead(TokenType.INITSECTIONMARK, TokenType.MAINSECTIONMARK);
                switch (tok.Type)
                {
                    case TokenType.INITSECTIONMARK:

                        
                        ParseInitSection(node);

                        
                        tok = scanner.LookAhead(TokenType.MAINSECTIONMARK);
                        if (tok.Type == TokenType.MAINSECTIONMARK)
                        {
                            ParseMainSection(node);
                        }
                        break;
                    case TokenType.MAINSECTIONMARK:

                        
                        ParseMainSection(node);

                        
                        tok = scanner.LookAhead(TokenType.INITSECTIONMARK);
                        if (tok.Type == TokenType.INITSECTIONMARK)
                        {
                            ParseInitSection(node);
                        }
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                        break;
                }
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseStart(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Start), "Start");
            parent.Nodes.Add(node);


            
            tok = scanner.LookAhead(TokenType.ENDL);
            if (tok.Type == TokenType.ENDL)
            {
                tok = scanner.Scan(TokenType.ENDL);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.ENDL) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ENDL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            }

            
            tok = scanner.LookAhead(TokenType.FUNCTIONSECTIONMARK);
            while (tok.Type == TokenType.FUNCTIONSECTIONMARK)
            {
                ParseCodePart(node);
            tok = scanner.LookAhead(TokenType.FUNCTIONSECTIONMARK);
            }

            
            tok = scanner.Scan(TokenType.EOF);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOF) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }


    }

    #endregion Parser
}
