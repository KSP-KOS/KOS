// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;

namespace kOS.Compilation.KS
{
    #region Parser

    public partial class Parser 
    {
        private Scanner scanner;
        private ParseTree tree;
        
        public Parser(Scanner scanner)
        {
            this.scanner = scanner;
        }

         public ParseTree Parse(string input)
        {
            return Parse(input, "", new ParseTree());
        }

        public ParseTree Parse(string input, string fileName)
        {
            return Parse(input, fileName, new ParseTree());
        }

        public ParseTree Parse(string input, string fileName, ParseTree tree)
        {
            scanner.Init(input, fileName);

            this.tree = tree;
            ParseStart(tree);
            tree.Skipped = scanner.Skipped;

            return tree;
        }

        private void ParseStart(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Start), "Start");
            parent.Nodes.Add(node);


            
            tok = scanner.LookAhead(TokenType.SET, TokenType.IF, TokenType.UNTIL, TokenType.LOCK, TokenType.UNLOCK, TokenType.PRINT, TokenType.ON, TokenType.TOGGLE, TokenType.WAIT, TokenType.WHEN, TokenType.IDENTIFIER, TokenType.STAGE, TokenType.CLEARSCREEN, TokenType.ADD, TokenType.REMOVE, TokenType.LOG, TokenType.BREAK, TokenType.DECLARE, TokenType.SWITCH, TokenType.COPY, TokenType.RENAME, TokenType.DELETE, TokenType.EDIT, TokenType.RUN, TokenType.LIST, TokenType.REBOOT, TokenType.SHUTDOWN, TokenType.FOR);
            while (tok.Type == TokenType.SET
                || tok.Type == TokenType.IF
                || tok.Type == TokenType.UNTIL
                || tok.Type == TokenType.LOCK
                || tok.Type == TokenType.UNLOCK
                || tok.Type == TokenType.PRINT
                || tok.Type == TokenType.ON
                || tok.Type == TokenType.TOGGLE
                || tok.Type == TokenType.WAIT
                || tok.Type == TokenType.WHEN
                || tok.Type == TokenType.IDENTIFIER
                || tok.Type == TokenType.STAGE
                || tok.Type == TokenType.CLEARSCREEN
                || tok.Type == TokenType.ADD
                || tok.Type == TokenType.REMOVE
                || tok.Type == TokenType.LOG
                || tok.Type == TokenType.BREAK
                || tok.Type == TokenType.DECLARE
                || tok.Type == TokenType.SWITCH
                || tok.Type == TokenType.COPY
                || tok.Type == TokenType.RENAME
                || tok.Type == TokenType.DELETE
                || tok.Type == TokenType.EDIT
                || tok.Type == TokenType.RUN
                || tok.Type == TokenType.LIST
                || tok.Type == TokenType.REBOOT
                || tok.Type == TokenType.SHUTDOWN
                || tok.Type == TokenType.FOR)
            {
                Parseinstruction(node);
            tok = scanner.LookAhead(TokenType.SET, TokenType.IF, TokenType.UNTIL, TokenType.LOCK, TokenType.UNLOCK, TokenType.PRINT, TokenType.ON, TokenType.TOGGLE, TokenType.WAIT, TokenType.WHEN, TokenType.IDENTIFIER, TokenType.STAGE, TokenType.CLEARSCREEN, TokenType.ADD, TokenType.REMOVE, TokenType.LOG, TokenType.BREAK, TokenType.DECLARE, TokenType.SWITCH, TokenType.COPY, TokenType.RENAME, TokenType.DELETE, TokenType.EDIT, TokenType.RUN, TokenType.LIST, TokenType.REBOOT, TokenType.SHUTDOWN, TokenType.FOR);
            }

            
            tok = scanner.Scan(TokenType.EOF);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOF) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseinstruction_block(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.instruction_block), "instruction_block");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.SET, TokenType.IF, TokenType.UNTIL, TokenType.LOCK, TokenType.UNLOCK, TokenType.PRINT, TokenType.ON, TokenType.TOGGLE, TokenType.WAIT, TokenType.WHEN, TokenType.IDENTIFIER, TokenType.STAGE, TokenType.CLEARSCREEN, TokenType.ADD, TokenType.REMOVE, TokenType.LOG, TokenType.BREAK, TokenType.DECLARE, TokenType.SWITCH, TokenType.COPY, TokenType.RENAME, TokenType.DELETE, TokenType.EDIT, TokenType.RUN, TokenType.LIST, TokenType.REBOOT, TokenType.SHUTDOWN, TokenType.FOR, TokenType.CURLYOPEN);
            switch (tok.Type)
            {
                case TokenType.SET:
                case TokenType.IF:
                case TokenType.UNTIL:
                case TokenType.LOCK:
                case TokenType.UNLOCK:
                case TokenType.PRINT:
                case TokenType.ON:
                case TokenType.TOGGLE:
                case TokenType.WAIT:
                case TokenType.WHEN:
                case TokenType.IDENTIFIER:
                case TokenType.STAGE:
                case TokenType.CLEARSCREEN:
                case TokenType.ADD:
                case TokenType.REMOVE:
                case TokenType.LOG:
                case TokenType.BREAK:
                case TokenType.DECLARE:
                case TokenType.SWITCH:
                case TokenType.COPY:
                case TokenType.RENAME:
                case TokenType.DELETE:
                case TokenType.EDIT:
                case TokenType.RUN:
                case TokenType.LIST:
                case TokenType.REBOOT:
                case TokenType.SHUTDOWN:
                case TokenType.FOR:
                    Parseinstruction(node);
                    break;
                case TokenType.CURLYOPEN:

                    
                    tok = scanner.Scan(TokenType.CURLYOPEN);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CURLYOPEN) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CURLYOPEN.ToString(), 0x1001, tok));
                        return;
                    }

                    
                    do {
                        Parseinstruction(node);
                        tok = scanner.LookAhead(TokenType.SET, TokenType.IF, TokenType.UNTIL, TokenType.LOCK, TokenType.UNLOCK, TokenType.PRINT, TokenType.ON, TokenType.TOGGLE, TokenType.WAIT, TokenType.WHEN, TokenType.IDENTIFIER, TokenType.STAGE, TokenType.CLEARSCREEN, TokenType.ADD, TokenType.REMOVE, TokenType.LOG, TokenType.BREAK, TokenType.DECLARE, TokenType.SWITCH, TokenType.COPY, TokenType.RENAME, TokenType.DELETE, TokenType.EDIT, TokenType.RUN, TokenType.LIST, TokenType.REBOOT, TokenType.SHUTDOWN, TokenType.FOR);
                    } while (tok.Type == TokenType.SET
                        || tok.Type == TokenType.IF
                        || tok.Type == TokenType.UNTIL
                        || tok.Type == TokenType.LOCK
                        || tok.Type == TokenType.UNLOCK
                        || tok.Type == TokenType.PRINT
                        || tok.Type == TokenType.ON
                        || tok.Type == TokenType.TOGGLE
                        || tok.Type == TokenType.WAIT
                        || tok.Type == TokenType.WHEN
                        || tok.Type == TokenType.IDENTIFIER
                        || tok.Type == TokenType.STAGE
                        || tok.Type == TokenType.CLEARSCREEN
                        || tok.Type == TokenType.ADD
                        || tok.Type == TokenType.REMOVE
                        || tok.Type == TokenType.LOG
                        || tok.Type == TokenType.BREAK
                        || tok.Type == TokenType.DECLARE
                        || tok.Type == TokenType.SWITCH
                        || tok.Type == TokenType.COPY
                        || tok.Type == TokenType.RENAME
                        || tok.Type == TokenType.DELETE
                        || tok.Type == TokenType.EDIT
                        || tok.Type == TokenType.RUN
                        || tok.Type == TokenType.LIST
                        || tok.Type == TokenType.REBOOT
                        || tok.Type == TokenType.SHUTDOWN
                        || tok.Type == TokenType.FOR);

                    
                    tok = scanner.Scan(TokenType.CURLYCLOSE);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CURLYCLOSE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CURLYCLOSE.ToString(), 0x1001, tok));
                        return;
                    }

                    
                    tok = scanner.LookAhead(TokenType.EOI);
                    if (tok.Type == TokenType.EOI)
                    {
                        tok = scanner.Scan(TokenType.EOI);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.EOI) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                            return;
                        }
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseinstruction(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.instruction), "instruction");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.SET, TokenType.IF, TokenType.UNTIL, TokenType.LOCK, TokenType.UNLOCK, TokenType.PRINT, TokenType.ON, TokenType.TOGGLE, TokenType.WAIT, TokenType.WHEN, TokenType.IDENTIFIER, TokenType.STAGE, TokenType.CLEARSCREEN, TokenType.ADD, TokenType.REMOVE, TokenType.LOG, TokenType.BREAK, TokenType.DECLARE, TokenType.SWITCH, TokenType.COPY, TokenType.RENAME, TokenType.DELETE, TokenType.EDIT, TokenType.RUN, TokenType.LIST, TokenType.REBOOT, TokenType.SHUTDOWN, TokenType.FOR);
            switch (tok.Type)
            {
                case TokenType.SET:
                    Parseset_stmt(node);
                    break;
                case TokenType.IF:
                    Parseif_stmt(node);
                    break;
                case TokenType.UNTIL:
                    Parseuntil_stmt(node);
                    break;
                case TokenType.LOCK:
                    Parselock_stmt(node);
                    break;
                case TokenType.UNLOCK:
                    Parseunlock_stmt(node);
                    break;
                case TokenType.PRINT:
                    Parseprint_stmt(node);
                    break;
                case TokenType.ON:
                    Parseon_stmt(node);
                    break;
                case TokenType.TOGGLE:
                    Parsetoggle_stmt(node);
                    break;
                case TokenType.WAIT:
                    Parsewait_stmt(node);
                    break;
                case TokenType.WHEN:
                    Parsewhen_stmt(node);
                    break;
                case TokenType.IDENTIFIER:
                    Parseonoff_stmt(node);
                    break;
                case TokenType.STAGE:
                    Parsestage_stmt(node);
                    break;
                case TokenType.CLEARSCREEN:
                    Parseclear_stmt(node);
                    break;
                case TokenType.ADD:
                    Parseadd_stmt(node);
                    break;
                case TokenType.REMOVE:
                    Parseremove_stmt(node);
                    break;
                case TokenType.LOG:
                    Parselog_stmt(node);
                    break;
                case TokenType.BREAK:
                    Parsebreak_stmt(node);
                    break;
                case TokenType.DECLARE:
                    Parsedeclare_stmt(node);
                    break;
                case TokenType.SWITCH:
                    Parseswitch_stmt(node);
                    break;
                case TokenType.COPY:
                    Parsecopy_stmt(node);
                    break;
                case TokenType.RENAME:
                    Parserename_stmt(node);
                    break;
                case TokenType.DELETE:
                    Parsedelete_stmt(node);
                    break;
                case TokenType.EDIT:
                    Parseedit_stmt(node);
                    break;
                case TokenType.RUN:
                    Parserun_stmt(node);
                    break;
                case TokenType.LIST:
                    Parselist_stmt(node);
                    break;
                case TokenType.REBOOT:
                    Parsereboot_stmt(node);
                    break;
                case TokenType.SHUTDOWN:
                    Parseshutdown_stmt(node);
                    break;
                case TokenType.FOR:
                    Parsefor_stmt(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseset_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.set_stmt), "set_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.SET);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SET) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SET.ToString(), 0x1001, tok));
                return;
            }

            
            Parsevaridentifier(node);

            
            tok = scanner.Scan(TokenType.TO);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TO.ToString(), 0x1001, tok));
                return;
            }

            
            Parseexpr(node);

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseif_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.if_stmt), "if_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.IF);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IF) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IF.ToString(), 0x1001, tok));
                return;
            }

            
            Parseexpr(node);

            
            Parseinstruction_block(node);

            
            tok = scanner.LookAhead(TokenType.EOI);
            if (tok.Type == TokenType.EOI)
            {
                tok = scanner.Scan(TokenType.EOI);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.EOI) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseuntil_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.until_stmt), "until_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.UNTIL);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.UNTIL) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.UNTIL.ToString(), 0x1001, tok));
                return;
            }

            
            Parseexpr(node);

            
            Parseinstruction_block(node);

            
            tok = scanner.LookAhead(TokenType.EOI);
            if (tok.Type == TokenType.EOI)
            {
                tok = scanner.Scan(TokenType.EOI);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.EOI) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parselock_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.lock_stmt), "lock_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.LOCK);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LOCK) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LOCK.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.TO);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TO.ToString(), 0x1001, tok));
                return;
            }

            
            Parseexpr(node);

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseunlock_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.unlock_stmt), "unlock_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.UNLOCK);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.UNLOCK) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.UNLOCK.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseprint_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.print_stmt), "print_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.PRINT);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PRINT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PRINT.ToString(), 0x1001, tok));
                return;
            }

            
            Parseexpr(node);

            
            tok = scanner.LookAhead(TokenType.AT);
            if (tok.Type == TokenType.AT)
            {

                
                tok = scanner.Scan(TokenType.AT);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.AT) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.AT.ToString(), 0x1001, tok));
                    return;
                }

                
                tok = scanner.Scan(TokenType.BRACKETOPEN);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.BRACKETOPEN) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString(), 0x1001, tok));
                    return;
                }

                
                tok = scanner.Scan(TokenType.INTEGER);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.INTEGER) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INTEGER.ToString(), 0x1001, tok));
                    return;
                }

                
                tok = scanner.Scan(TokenType.COMMA);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, tok));
                    return;
                }

                
                tok = scanner.Scan(TokenType.INTEGER);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.INTEGER) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INTEGER.ToString(), 0x1001, tok));
                    return;
                }

                
                tok = scanner.Scan(TokenType.BRACKETCLOSE);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.BRACKETCLOSE) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString(), 0x1001, tok));
                    return;
                }
            }

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseon_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.on_stmt), "on_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.ON);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ON) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ON.ToString(), 0x1001, tok));
                return;
            }

            
            Parsevaridentifier(node);

            
            Parseinstruction_block(node);

            
            tok = scanner.LookAhead(TokenType.EOI);
            if (tok.Type == TokenType.EOI)
            {
                tok = scanner.Scan(TokenType.EOI);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.EOI) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsetoggle_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.toggle_stmt), "toggle_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.TOGGLE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TOGGLE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TOGGLE.ToString(), 0x1001, tok));
                return;
            }

            
            Parsevaridentifier(node);

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsewait_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.wait_stmt), "wait_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.WAIT);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.WAIT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WAIT.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.UNTIL);
            if (tok.Type == TokenType.UNTIL)
            {
                tok = scanner.Scan(TokenType.UNTIL);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.UNTIL) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.UNTIL.ToString(), 0x1001, tok));
                    return;
                }
            }

            
            Parseexpr(node);

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsewhen_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.when_stmt), "when_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.WHEN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.WHEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WHEN.ToString(), 0x1001, tok));
                return;
            }

            
            Parseexpr(node);

            
            tok = scanner.Scan(TokenType.THEN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.THEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.THEN.ToString(), 0x1001, tok));
                return;
            }

            
            Parseinstruction_block(node);

            
            tok = scanner.LookAhead(TokenType.EOI);
            if (tok.Type == TokenType.EOI)
            {
                tok = scanner.Scan(TokenType.EOI);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.EOI) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseonoff_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.onoff_stmt), "onoff_stmt");
            parent.Nodes.Add(node);


            
            Parsevaridentifier(node);

            
            tok = scanner.LookAhead(TokenType.ON, TokenType.OFF);
            switch (tok.Type)
            {
                case TokenType.ON:
                    tok = scanner.Scan(TokenType.ON);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.ON) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ON.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.OFF:
                    tok = scanner.Scan(TokenType.OFF);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.OFF) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OFF.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                    break;
            }

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsestage_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.stage_stmt), "stage_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.STAGE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.STAGE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STAGE.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseclear_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.clear_stmt), "clear_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.CLEARSCREEN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CLEARSCREEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CLEARSCREEN.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseadd_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.add_stmt), "add_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.ADD);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.ADD) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ADD.ToString(), 0x1001, tok));
                return;
            }

            
            Parseexpr(node);

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseremove_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.remove_stmt), "remove_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.REMOVE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.REMOVE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.REMOVE.ToString(), 0x1001, tok));
                return;
            }

            
            Parseexpr(node);

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parselog_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.log_stmt), "log_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.LOG);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LOG) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LOG.ToString(), 0x1001, tok));
                return;
            }

            
            Parseexpr(node);

            
            tok = scanner.Scan(TokenType.TO);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TO.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsebreak_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.break_stmt), "break_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.BREAK);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BREAK) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BREAK.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsedeclare_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.declare_stmt), "declare_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.DECLARE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.DECLARE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DECLARE.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.PARAMETER);
            if (tok.Type == TokenType.PARAMETER)
            {
                tok = scanner.Scan(TokenType.PARAMETER);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.PARAMETER) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PARAMETER.ToString(), 0x1001, tok));
                    return;
                }
            }

            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.COMMA);
            while (tok.Type == TokenType.COMMA)
            {

                
                tok = scanner.Scan(TokenType.COMMA);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, tok));
                    return;
                }

                
                tok = scanner.Scan(TokenType.IDENTIFIER);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.IDENTIFIER) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                    return;
                }
            tok = scanner.LookAhead(TokenType.COMMA);
            }

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseswitch_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.switch_stmt), "switch_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.SWITCH);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SWITCH) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SWITCH.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.TO);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TO.ToString(), 0x1001, tok));
                return;
            }

            
            Parsefilevol_name(node);

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsecopy_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.copy_stmt), "copy_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.COPY);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.COPY) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COPY.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.FROM, TokenType.TO);
            switch (tok.Type)
            {
                case TokenType.FROM:
                    tok = scanner.Scan(TokenType.FROM);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.FROM) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FROM.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.TO:
                    tok = scanner.Scan(TokenType.TO);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.TO) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TO.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                    break;
            }

            
            Parsefilevol_name(node);

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parserename_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.rename_stmt), "rename_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.RENAME);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RENAME) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RENAME.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.VOLUME, TokenType.FILE);
            if (tok.Type == TokenType.VOLUME
                || tok.Type == TokenType.FILE)
            {
                tok = scanner.LookAhead(TokenType.VOLUME, TokenType.FILE);
                switch (tok.Type)
                {
                    case TokenType.VOLUME:
                        tok = scanner.Scan(TokenType.VOLUME);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.VOLUME) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.VOLUME.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    case TokenType.FILE:
                        tok = scanner.Scan(TokenType.FILE);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.FILE) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FILE.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                        break;
                }
            }

            
            Parsefilevol_name(node);

            
            tok = scanner.Scan(TokenType.TO);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TO.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsedelete_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.delete_stmt), "delete_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.DELETE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.DELETE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DELETE.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.FROM);
            if (tok.Type == TokenType.FROM)
            {

                
                tok = scanner.Scan(TokenType.FROM);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.FROM) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FROM.ToString(), 0x1001, tok));
                    return;
                }

                
                Parsefilevol_name(node);
            }

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseedit_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.edit_stmt), "edit_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.EDIT);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EDIT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EDIT.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parserun_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.run_stmt), "run_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.RUN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RUN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RUN.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.BRACKETOPEN);
            if (tok.Type == TokenType.BRACKETOPEN)
            {

                
                tok = scanner.Scan(TokenType.BRACKETOPEN);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.BRACKETOPEN) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString(), 0x1001, tok));
                    return;
                }

                
                Parsearglist(node);

                
                tok = scanner.Scan(TokenType.BRACKETCLOSE);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.BRACKETCLOSE) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString(), 0x1001, tok));
                    return;
                }
            }

            
            tok = scanner.LookAhead(TokenType.ON);
            if (tok.Type == TokenType.ON)
            {

                
                tok = scanner.Scan(TokenType.ON);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.ON) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ON.ToString(), 0x1001, tok));
                    return;
                }

                
                Parsefilevol_name(node);
            }

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsefilevol_name(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.filevol_name), "filevol_name");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.INTEGER, TokenType.IDENTIFIER);
            switch (tok.Type)
            {
                case TokenType.INTEGER:
                    tok = scanner.Scan(TokenType.INTEGER);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.INTEGER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INTEGER.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.IDENTIFIER:
                    tok = scanner.Scan(TokenType.IDENTIFIER);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IDENTIFIER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parselist_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.list_stmt), "list_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.LIST);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LIST) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LIST.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.IDENTIFIER);
            if (tok.Type == TokenType.IDENTIFIER)
            {
                tok = scanner.Scan(TokenType.IDENTIFIER);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.IDENTIFIER) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                    return;
                }
            }

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsereboot_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.reboot_stmt), "reboot_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.REBOOT);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.REBOOT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.REBOOT.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseshutdown_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.shutdown_stmt), "shutdown_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.SHUTDOWN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.SHUTDOWN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SHUTDOWN.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.EOI);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOI) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsefor_stmt(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.for_stmt), "for_stmt");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.FOR);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.FOR) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOR.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.Scan(TokenType.IN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IN.ToString(), 0x1001, tok));
                return;
            }

            
            Parsevaridentifier(node);

            
            Parseinstruction_block(node);

            
            tok = scanner.LookAhead(TokenType.EOI);
            if (tok.Type == TokenType.EOI)
            {
                tok = scanner.Scan(TokenType.EOI);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.EOI) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOI.ToString(), 0x1001, tok));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsearglist(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.arglist), "arglist");
            parent.Nodes.Add(node);


            
            Parseexpr(node);

            
            tok = scanner.LookAhead(TokenType.COMMA);
            while (tok.Type == TokenType.COMMA)
            {

                
                tok = scanner.Scan(TokenType.COMMA);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, tok));
                    return;
                }

                
                Parseexpr(node);
            tok = scanner.LookAhead(TokenType.COMMA);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseexpr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.expr), "expr");
            parent.Nodes.Add(node);


            
            Parseor_expr(node);

            
            tok = scanner.LookAhead(TokenType.COMPARATOR);
            while (tok.Type == TokenType.COMPARATOR)
            {

                
                tok = scanner.Scan(TokenType.COMPARATOR);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMPARATOR) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMPARATOR.ToString(), 0x1001, tok));
                    return;
                }

                
                Parseor_expr(node);
            tok = scanner.LookAhead(TokenType.COMPARATOR);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseor_expr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.or_expr), "or_expr");
            parent.Nodes.Add(node);


            
            Parseand_expr(node);

            
            tok = scanner.LookAhead(TokenType.OR);
            while (tok.Type == TokenType.OR)
            {

                
                tok = scanner.Scan(TokenType.OR);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.OR) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.OR.ToString(), 0x1001, tok));
                    return;
                }

                
                Parseand_expr(node);
            tok = scanner.LookAhead(TokenType.OR);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseand_expr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.and_expr), "and_expr");
            parent.Nodes.Add(node);


            
            Parsearith_expr(node);

            
            tok = scanner.LookAhead(TokenType.AND);
            while (tok.Type == TokenType.AND)
            {

                
                tok = scanner.Scan(TokenType.AND);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.AND) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.AND.ToString(), 0x1001, tok));
                    return;
                }

                
                Parsearith_expr(node);
            tok = scanner.LookAhead(TokenType.AND);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsearith_expr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.arith_expr), "arith_expr");
            parent.Nodes.Add(node);


            
            Parsediv_expr(node);

            
            tok = scanner.LookAhead(TokenType.PLUSMINUS);
            while (tok.Type == TokenType.PLUSMINUS)
            {

                
                tok = scanner.Scan(TokenType.PLUSMINUS);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.PLUSMINUS) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PLUSMINUS.ToString(), 0x1001, tok));
                    return;
                }

                
                Parsediv_expr(node);
            tok = scanner.LookAhead(TokenType.PLUSMINUS);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsediv_expr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.div_expr), "div_expr");
            parent.Nodes.Add(node);


            
            Parsemult_expr(node);

            
            tok = scanner.LookAhead(TokenType.DIV);
            while (tok.Type == TokenType.DIV)
            {

                
                tok = scanner.Scan(TokenType.DIV);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.DIV) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DIV.ToString(), 0x1001, tok));
                    return;
                }

                
                Parsemult_expr(node);
            tok = scanner.LookAhead(TokenType.DIV);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsemult_expr(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.mult_expr), "mult_expr");
            parent.Nodes.Add(node);


            
            Parsefactor(node);

            
            tok = scanner.LookAhead(TokenType.MULT);
            while (tok.Type == TokenType.MULT)
            {

                
                tok = scanner.Scan(TokenType.MULT);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.MULT) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MULT.ToString(), 0x1001, tok));
                    return;
                }

                
                Parsefactor(node);
            tok = scanner.LookAhead(TokenType.MULT);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsefactor(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.factor), "factor");
            parent.Nodes.Add(node);


            
            Parseatom(node);

            
            tok = scanner.LookAhead(TokenType.POWER);
            while (tok.Type == TokenType.POWER)
            {

                
                tok = scanner.Scan(TokenType.POWER);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.POWER) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.POWER.ToString(), 0x1001, tok));
                    return;
                }

                
                Parseatom(node);
            tok = scanner.LookAhead(TokenType.POWER);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parseatom(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.atom), "atom");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.PLUSMINUS, TokenType.INTEGER, TokenType.DOUBLE, TokenType.TRUEFALSE, TokenType.IDENTIFIER, TokenType.BRACKETOPEN, TokenType.STRING);
            switch (tok.Type)
            {
                case TokenType.PLUSMINUS:
                case TokenType.INTEGER:
                case TokenType.DOUBLE:
                case TokenType.TRUEFALSE:
                case TokenType.IDENTIFIER:
                case TokenType.BRACKETOPEN:

                    
                    tok = scanner.LookAhead(TokenType.PLUSMINUS);
                    if (tok.Type == TokenType.PLUSMINUS)
                    {
                        tok = scanner.Scan(TokenType.PLUSMINUS);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.PLUSMINUS) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PLUSMINUS.ToString(), 0x1001, tok));
                            return;
                        }
                    }

                    
                    tok = scanner.LookAhead(TokenType.INTEGER, TokenType.DOUBLE, TokenType.TRUEFALSE, TokenType.IDENTIFIER, TokenType.BRACKETOPEN);
                    switch (tok.Type)
                    {
                        case TokenType.INTEGER:
                        case TokenType.DOUBLE:
                            Parsesci_number(node);
                            break;
                        case TokenType.TRUEFALSE:
                            tok = scanner.Scan(TokenType.TRUEFALSE);
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.TRUEFALSE) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TRUEFALSE.ToString(), 0x1001, tok));
                                return;
                            }
                            break;
                        case TokenType.IDENTIFIER:
                            Parsevaridentifier(node);
                            break;
                        case TokenType.BRACKETOPEN:

                            
                            tok = scanner.Scan(TokenType.BRACKETOPEN);
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.BRACKETOPEN) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString(), 0x1001, tok));
                                return;
                            }

                            
                            Parseexpr(node);

                            
                            tok = scanner.Scan(TokenType.BRACKETCLOSE);
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.BRACKETCLOSE) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString(), 0x1001, tok));
                                return;
                            }
                            break;
                        default:
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                            break;
                    }
                    break;
                case TokenType.STRING:
                    tok = scanner.Scan(TokenType.STRING);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.STRING) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsesci_number(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.sci_number), "sci_number");
            parent.Nodes.Add(node);


            
            Parsenumber(node);

            
            tok = scanner.LookAhead(TokenType.E);
            if (tok.Type == TokenType.E)
            {

                
                tok = scanner.Scan(TokenType.E);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.E) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.E.ToString(), 0x1001, tok));
                    return;
                }

                
                tok = scanner.Scan(TokenType.INTEGER);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.INTEGER) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INTEGER.ToString(), 0x1001, tok));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsenumber(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.number), "number");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.INTEGER, TokenType.DOUBLE);
            switch (tok.Type)
            {
                case TokenType.INTEGER:
                    tok = scanner.Scan(TokenType.INTEGER);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.INTEGER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INTEGER.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.DOUBLE:
                    tok = scanner.Scan(TokenType.DOUBLE);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.DOUBLE) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOUBLE.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsevaridentifier(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.varidentifier), "varidentifier");
            parent.Nodes.Add(node);


            
            Parsearray_identifier(node);

            
            tok = scanner.LookAhead(TokenType.COLON);
            while (tok.Type == TokenType.COLON)
            {

                
                tok = scanner.Scan(TokenType.COLON);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COLON) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLON.ToString(), 0x1001, tok));
                    return;
                }

                
                tok = scanner.Scan(TokenType.IDENTIFIER);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.IDENTIFIER) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                    return;
                }
            tok = scanner.LookAhead(TokenType.COLON);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsearray_identifier(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.array_identifier), "array_identifier");
            parent.Nodes.Add(node);


            
            Parsefunction_identifier(node);

            
            tok = scanner.LookAhead(TokenType.ARRAYINDEX);
            while (tok.Type == TokenType.ARRAYINDEX)
            {

                
                tok = scanner.Scan(TokenType.ARRAYINDEX);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.ARRAYINDEX) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.ARRAYINDEX.ToString(), 0x1001, tok));
                    return;
                }

                
                tok = scanner.LookAhead(TokenType.INTEGER, TokenType.IDENTIFIER);
                switch (tok.Type)
                {
                    case TokenType.INTEGER:
                        tok = scanner.Scan(TokenType.INTEGER);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.INTEGER) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INTEGER.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    case TokenType.IDENTIFIER:
                        tok = scanner.Scan(TokenType.IDENTIFIER);
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.IDENTIFIER) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                            return;
                        }
                        break;
                    default:
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, tok));
                        break;
                }
            tok = scanner.LookAhead(TokenType.ARRAYINDEX);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void Parsefunction_identifier(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.function_identifier), "function_identifier");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.IDENTIFIER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFIER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFIER.ToString(), 0x1001, tok));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.BRACKETOPEN);
            if (tok.Type == TokenType.BRACKETOPEN)
            {

                
                tok = scanner.Scan(TokenType.BRACKETOPEN);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.BRACKETOPEN) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETOPEN.ToString(), 0x1001, tok));
                    return;
                }

                
                tok = scanner.LookAhead(TokenType.PLUSMINUS, TokenType.INTEGER, TokenType.DOUBLE, TokenType.TRUEFALSE, TokenType.IDENTIFIER, TokenType.BRACKETOPEN, TokenType.STRING);
                if (tok.Type == TokenType.PLUSMINUS
                    || tok.Type == TokenType.INTEGER
                    || tok.Type == TokenType.DOUBLE
                    || tok.Type == TokenType.TRUEFALSE
                    || tok.Type == TokenType.IDENTIFIER
                    || tok.Type == TokenType.BRACKETOPEN
                    || tok.Type == TokenType.STRING)
                {
                    Parsearglist(node);
                }

                
                tok = scanner.Scan(TokenType.BRACKETCLOSE);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.BRACKETCLOSE) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BRACKETCLOSE.ToString(), 0x1001, tok));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        }


    }

    #endregion Parser
}
