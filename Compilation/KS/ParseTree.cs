// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

namespace kOS.Compilation.KS
{
    #region ParseTree
    [Serializable]
    public class ParseErrors : List<ParseError>
    {
    }

    [Serializable]
    public class ParseError
    {
        private string file;
        private string message;
        private int code;
        private int line;
        private int col;
        private int pos;
        private int length;

        public string File { get { return file; } }
        public int Code { get { return code; } }
        public int Line { get { return line; } }
        public int Column { get { return col; } }
        public int Position { get { return pos; } }
        public int Length { get { return length; } }
        public string Message { get { return message; } }

        // just for the sake of serialization
        public ParseError()
        {
        }

        public ParseError(string message, int code, ParseNode node) : this(message, code, node.Token)
        {
        }

        public ParseError(string message, int code, Token token) : this(message, code, token.File, token.Line, token.Column, token.StartPos, token.Length)
        {
        }

        public ParseError(string message, int code) : this(message, code, string.Empty, 0, 0, 0, 0)
        {
        }

        public ParseError(string message, int code, string file, int line, int col, int pos, int length)
        {
            this.file = file;
            this.message = message;
            this.code = code;
            this.line = line;
            this.col = col;
            this.pos = pos;
            this.length = length;
        }
    }

    // rootlevel of the node tree
    [Serializable]
    public partial class ParseTree : ParseNode
    {
        public ParseErrors Errors;

        public List<Token> Skipped;

        public ParseTree() : base(new Token(), "ParseTree")
        {
            Token.Type = TokenType.Start;
            Token.Text = "Root";
            Errors = new ParseErrors();
        }

        public string PrintTree()
        {
            StringBuilder sb = new StringBuilder();
            int indent = 0;
            PrintNode(sb, this, indent);
            return sb.ToString();
        }

        private void PrintNode(StringBuilder sb, ParseNode node, int indent)
        {
            
            string space = "".PadLeft(indent, ' ');

            sb.Append(space);
            sb.AppendLine(node.Text);

            foreach (ParseNode n in node.Nodes)
                PrintNode(sb, n, indent + 2);
        }
        
        /// <summary>
        /// this is the entry point for executing and evaluating the parse tree.
        /// </summary>
        /// <param name="paramlist">additional optional input parameters</param>
        /// <returns>the output of the evaluation function</returns>
        public object Eval(params object[] paramlist)
        {
            return Nodes[0].Eval(this, paramlist);
        }
    }

    [Serializable]
    [XmlInclude(typeof(ParseTree))]
    public partial class ParseNode
    {
        protected string text;
        protected List<ParseNode> nodes;
        
        public List<ParseNode> Nodes { get {return nodes;} }
        
        [XmlIgnore] // avoid circular references when serializing
        public ParseNode Parent;
        public Token Token; // the token/rule

        [XmlIgnore] // skip redundant text (is part of Token)
        public string Text { // text to display in parse tree 
            get { return text;} 
            set { text = value; }
        } 

        public virtual ParseNode CreateNode(Token token, string text)
        {
            ParseNode node = new ParseNode(token, text);
            node.Parent = this;
            return node;
        }

        protected ParseNode(Token token, string text)
        {
            this.Token = token;
            this.text = text;
            this.nodes = new List<ParseNode>();
        }

        protected object GetValue(ParseTree tree, TokenType type, int index)
        {
            return GetValue(tree, type, ref index);
        }

        protected object GetValue(ParseTree tree, TokenType type, ref int index)
        {
            object o = null;
            if (index < 0) return o;

            // left to right
            foreach (ParseNode node in nodes)
            {
                if (node.Token.Type == type)
                {
                    index--;
                    if (index < 0)
                    {
                        o = node.Eval(tree);
                        break;
                    }
                }
            }
            return o;
        }

        /// <summary>
        /// this implements the evaluation functionality, cannot be used directly
        /// </summary>
        /// <param name="tree">the parsetree itself</param>
        /// <param name="paramlist">optional input parameters</param>
        /// <returns>a partial result of the evaluation</returns>
        internal object Eval(ParseTree tree, params object[] paramlist)
        {
            object Value = null;

            switch (Token.Type)
            {
                case TokenType.Start:
                    Value = EvalStart(tree, paramlist);
                    break;
                case TokenType.instruction_block:
                    Value = Evalinstruction_block(tree, paramlist);
                    break;
                case TokenType.instruction:
                    Value = Evalinstruction(tree, paramlist);
                    break;
                case TokenType.set_stmt:
                    Value = Evalset_stmt(tree, paramlist);
                    break;
                case TokenType.if_stmt:
                    Value = Evalif_stmt(tree, paramlist);
                    break;
                case TokenType.until_stmt:
                    Value = Evaluntil_stmt(tree, paramlist);
                    break;
                case TokenType.lock_stmt:
                    Value = Evallock_stmt(tree, paramlist);
                    break;
                case TokenType.unlock_stmt:
                    Value = Evalunlock_stmt(tree, paramlist);
                    break;
                case TokenType.print_stmt:
                    Value = Evalprint_stmt(tree, paramlist);
                    break;
                case TokenType.on_stmt:
                    Value = Evalon_stmt(tree, paramlist);
                    break;
                case TokenType.toggle_stmt:
                    Value = Evaltoggle_stmt(tree, paramlist);
                    break;
                case TokenType.wait_stmt:
                    Value = Evalwait_stmt(tree, paramlist);
                    break;
                case TokenType.when_stmt:
                    Value = Evalwhen_stmt(tree, paramlist);
                    break;
                case TokenType.onoff_stmt:
                    Value = Evalonoff_stmt(tree, paramlist);
                    break;
                case TokenType.stage_stmt:
                    Value = Evalstage_stmt(tree, paramlist);
                    break;
                case TokenType.clear_stmt:
                    Value = Evalclear_stmt(tree, paramlist);
                    break;
                case TokenType.add_stmt:
                    Value = Evaladd_stmt(tree, paramlist);
                    break;
                case TokenType.remove_stmt:
                    Value = Evalremove_stmt(tree, paramlist);
                    break;
                case TokenType.log_stmt:
                    Value = Evallog_stmt(tree, paramlist);
                    break;
                case TokenType.break_stmt:
                    Value = Evalbreak_stmt(tree, paramlist);
                    break;
                case TokenType.declare_stmt:
                    Value = Evaldeclare_stmt(tree, paramlist);
                    break;
                case TokenType.switch_stmt:
                    Value = Evalswitch_stmt(tree, paramlist);
                    break;
                case TokenType.copy_stmt:
                    Value = Evalcopy_stmt(tree, paramlist);
                    break;
                case TokenType.rename_stmt:
                    Value = Evalrename_stmt(tree, paramlist);
                    break;
                case TokenType.delete_stmt:
                    Value = Evaldelete_stmt(tree, paramlist);
                    break;
                case TokenType.edit_stmt:
                    Value = Evaledit_stmt(tree, paramlist);
                    break;
                case TokenType.run_stmt:
                    Value = Evalrun_stmt(tree, paramlist);
                    break;
                case TokenType.filevol_name:
                    Value = Evalfilevol_name(tree, paramlist);
                    break;
                case TokenType.list_stmt:
                    Value = Evallist_stmt(tree, paramlist);
                    break;
                case TokenType.reboot_stmt:
                    Value = Evalreboot_stmt(tree, paramlist);
                    break;
                case TokenType.shutdown_stmt:
                    Value = Evalshutdown_stmt(tree, paramlist);
                    break;
                case TokenType.arglist:
                    Value = Evalarglist(tree, paramlist);
                    break;
                case TokenType.expr:
                    Value = Evalexpr(tree, paramlist);
                    break;
                case TokenType.or_expr:
                    Value = Evalor_expr(tree, paramlist);
                    break;
                case TokenType.and_expr:
                    Value = Evaland_expr(tree, paramlist);
                    break;
                case TokenType.arith_expr:
                    Value = Evalarith_expr(tree, paramlist);
                    break;
                case TokenType.div_expr:
                    Value = Evaldiv_expr(tree, paramlist);
                    break;
                case TokenType.mult_expr:
                    Value = Evalmult_expr(tree, paramlist);
                    break;
                case TokenType.factor:
                    Value = Evalfactor(tree, paramlist);
                    break;
                case TokenType.atom:
                    Value = Evalatom(tree, paramlist);
                    break;
                case TokenType.sci_number:
                    Value = Evalsci_number(tree, paramlist);
                    break;
                case TokenType.number:
                    Value = Evalnumber(tree, paramlist);
                    break;

                default:
                    Value = Token.Text;
                    break;
            }
            return Value;
        }

        protected virtual object EvalStart(ParseTree tree, params object[] paramlist)
        {
            return "Could not interpret input; no semantics implemented.";
        }

        protected virtual object Evalinstruction_block(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evalinstruction(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evalset_stmt(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evalif_stmt(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evaluntil_stmt(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evallock_stmt(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evalunlock_stmt(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evalprint_stmt(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evalon_stmt(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evaltoggle_stmt(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evalwait_stmt(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evalwhen_stmt(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evalonoff_stmt(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evalstage_stmt(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evalclear_stmt(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evaladd_stmt(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evalremove_stmt(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evallog_stmt(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evalbreak_stmt(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evaldeclare_stmt(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evalswitch_stmt(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evalcopy_stmt(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evalrename_stmt(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evaldelete_stmt(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evaledit_stmt(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evalrun_stmt(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evalfilevol_name(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evallist_stmt(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evalreboot_stmt(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evalshutdown_stmt(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evalarglist(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evalexpr(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evalor_expr(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evaland_expr(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evalarith_expr(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evaldiv_expr(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evalmult_expr(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evalfactor(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evalatom(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evalsci_number(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object Evalnumber(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }


    }
    
    #endregion ParseTree
}
